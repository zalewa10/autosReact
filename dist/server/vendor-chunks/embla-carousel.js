"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/embla-carousel";
exports.ids = ["vendor-chunks/embla-carousel"];
exports.modules = {

/***/ "(ssr)/./node_modules/embla-carousel/esm/embla-carousel.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/embla-carousel/esm/embla-carousel.esm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ EmblaCarousel)\n/* harmony export */ });\nfunction isNumber(subject) {\n    return typeof subject === \"number\";\n}\nfunction isString(subject) {\n    return typeof subject === \"string\";\n}\nfunction isBoolean(subject) {\n    return typeof subject === \"boolean\";\n}\nfunction isObject(subject) {\n    return Object.prototype.toString.call(subject) === \"[object Object]\";\n}\nfunction mathAbs(n) {\n    return Math.abs(n);\n}\nfunction mathSign(n) {\n    return Math.sign(n);\n}\nfunction deltaAbs(valueB, valueA) {\n    return mathAbs(valueB - valueA);\n}\nfunction factorAbs(valueB, valueA) {\n    if (valueB === 0 || valueA === 0) return 0;\n    if (mathAbs(valueB) <= mathAbs(valueA)) return 0;\n    const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA));\n    return mathAbs(diff / valueB);\n}\nfunction arrayKeys(array) {\n    return objectKeys(array).map(Number);\n}\nfunction arrayLast(array) {\n    return array[arrayLastIndex(array)];\n}\nfunction arrayLastIndex(array) {\n    return Math.max(0, array.length - 1);\n}\nfunction arrayIsLastIndex(array, index) {\n    return index === arrayLastIndex(array);\n}\nfunction arrayFromNumber(n, startAt = 0) {\n    return Array.from(Array(n), (_, i)=>startAt + i);\n}\nfunction objectKeys(object) {\n    return Object.keys(object);\n}\nfunction objectsMergeDeep(objectA, objectB) {\n    return [\n        objectA,\n        objectB\n    ].reduce((mergedObjects, currentObject)=>{\n        objectKeys(currentObject).forEach((key)=>{\n            const valueA = mergedObjects[key];\n            const valueB = currentObject[key];\n            const areObjects = isObject(valueA) && isObject(valueB);\n            mergedObjects[key] = areObjects ? objectsMergeDeep(valueA, valueB) : valueB;\n        });\n        return mergedObjects;\n    }, {});\n}\nfunction isMouseEvent(evt, ownerWindow) {\n    return typeof ownerWindow.MouseEvent !== \"undefined\" && evt instanceof ownerWindow.MouseEvent;\n}\nfunction Alignment(align, viewSize) {\n    const predefined = {\n        start,\n        center,\n        end\n    };\n    function start() {\n        return 0;\n    }\n    function center(n) {\n        return end(n) / 2;\n    }\n    function end(n) {\n        return viewSize - n;\n    }\n    function measure(n, index) {\n        if (isString(align)) return predefined[align](n);\n        return align(viewSize, n, index);\n    }\n    const self = {\n        measure\n    };\n    return self;\n}\nfunction EventStore() {\n    let listeners = [];\n    function add(node, type, handler, options = {\n        passive: true\n    }) {\n        let removeListener;\n        if (\"addEventListener\" in node) {\n            node.addEventListener(type, handler, options);\n            removeListener = ()=>node.removeEventListener(type, handler, options);\n        } else {\n            const legacyMediaQueryList = node;\n            legacyMediaQueryList.addListener(handler);\n            removeListener = ()=>legacyMediaQueryList.removeListener(handler);\n        }\n        listeners.push(removeListener);\n        return self;\n    }\n    function clear() {\n        listeners = listeners.filter((remove)=>remove());\n    }\n    const self = {\n        add,\n        clear\n    };\n    return self;\n}\nfunction Animations(ownerDocument, ownerWindow, update, render) {\n    const documentVisibleHandler = EventStore();\n    const timeStep = 1000 / 60;\n    let lastTimeStamp = null;\n    let lag = 0;\n    let animationFrame = 0;\n    function init() {\n        documentVisibleHandler.add(ownerDocument, \"visibilitychange\", ()=>{\n            if (ownerDocument.hidden) reset();\n        });\n    }\n    function destroy() {\n        stop();\n        documentVisibleHandler.clear();\n    }\n    function animate(timeStamp) {\n        if (!lastTimeStamp) lastTimeStamp = timeStamp;\n        const elapsed = timeStamp - lastTimeStamp;\n        lastTimeStamp = timeStamp;\n        lag += elapsed;\n        while(lag >= timeStep){\n            update();\n            lag -= timeStep;\n        }\n        const lagOffset = mathAbs(lag / timeStep);\n        render(lagOffset);\n        if (animationFrame) ownerWindow.requestAnimationFrame(animate);\n    }\n    function start() {\n        if (animationFrame) return;\n        animationFrame = ownerWindow.requestAnimationFrame(animate);\n    }\n    function stop() {\n        ownerWindow.cancelAnimationFrame(animationFrame);\n        lastTimeStamp = null;\n        lag = 0;\n        animationFrame = 0;\n    }\n    function reset() {\n        lastTimeStamp = null;\n        lag = 0;\n    }\n    const self = {\n        init,\n        destroy,\n        start,\n        stop,\n        update,\n        render\n    };\n    return self;\n}\nfunction Axis(axis, direction) {\n    const scroll = axis === \"y\" ? \"y\" : \"x\";\n    const cross = axis === \"y\" ? \"x\" : \"y\";\n    const startEdge = getStartEdge();\n    const endEdge = getEndEdge();\n    function measureSize(nodeRect) {\n        const { width, height } = nodeRect;\n        return scroll === \"x\" ? width : height;\n    }\n    function getStartEdge() {\n        if (scroll === \"y\") return \"top\";\n        return direction === \"rtl\" ? \"right\" : \"left\";\n    }\n    function getEndEdge() {\n        if (scroll === \"y\") return \"bottom\";\n        return direction === \"rtl\" ? \"left\" : \"right\";\n    }\n    const self = {\n        scroll,\n        cross,\n        startEdge,\n        endEdge,\n        measureSize\n    };\n    return self;\n}\nfunction Limit(min = 0, max = 0) {\n    const length = mathAbs(min - max);\n    function reachedMin(n) {\n        return n < min;\n    }\n    function reachedMax(n) {\n        return n > max;\n    }\n    function reachedAny(n) {\n        return reachedMin(n) || reachedMax(n);\n    }\n    function constrain(n) {\n        if (!reachedAny(n)) return n;\n        return reachedMin(n) ? min : max;\n    }\n    function removeOffset(n) {\n        if (!length) return n;\n        return n - length * Math.ceil((n - max) / length);\n    }\n    const self = {\n        length,\n        max,\n        min,\n        constrain,\n        reachedAny,\n        reachedMax,\n        reachedMin,\n        removeOffset\n    };\n    return self;\n}\nfunction Counter(max, start, loop) {\n    const { constrain } = Limit(0, max);\n    const loopEnd = max + 1;\n    let counter = withinLimit(start);\n    function withinLimit(n) {\n        return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd);\n    }\n    function get() {\n        return counter;\n    }\n    function set(n) {\n        counter = withinLimit(n);\n        return self;\n    }\n    function add(n) {\n        return clone().set(get() + n);\n    }\n    function clone() {\n        return Counter(max, get(), loop);\n    }\n    const self = {\n        get,\n        set,\n        add,\n        clone\n    };\n    return self;\n}\nfunction Direction(direction) {\n    const sign = direction === \"rtl\" ? -1 : 1;\n    function apply(n) {\n        return n * sign;\n    }\n    const self = {\n        apply\n    };\n    return self;\n}\nfunction DragHandler(axis, direction, rootNode, ownerDocument, ownerWindow, target, dragTracker, location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, baseFriction, watchDrag) {\n    const { cross: crossAxis } = axis;\n    const focusNodes = [\n        \"INPUT\",\n        \"SELECT\",\n        \"TEXTAREA\"\n    ];\n    const nonPassiveEvent = {\n        passive: false\n    };\n    const initEvents = EventStore();\n    const dragEvents = EventStore();\n    const goToNextThreshold = Limit(50, 225).constrain(percentOfView.measure(20));\n    const snapForceBoost = {\n        mouse: 300,\n        touch: 400\n    };\n    const freeForceBoost = {\n        mouse: 500,\n        touch: 600\n    };\n    const baseSpeed = dragFree ? 43 : 25;\n    let isMoving = false;\n    let startScroll = 0;\n    let startCross = 0;\n    let pointerIsDown = false;\n    let preventScroll = false;\n    let preventClick = false;\n    let isMouse = false;\n    function init(emblaApi) {\n        if (!watchDrag) return;\n        function downIfAllowed(evt) {\n            if (isBoolean(watchDrag) || watchDrag(emblaApi, evt)) down(evt);\n        }\n        const node = rootNode;\n        initEvents.add(node, \"dragstart\", (evt)=>evt.preventDefault(), nonPassiveEvent).add(node, \"touchmove\", ()=>undefined, nonPassiveEvent).add(node, \"touchend\", ()=>undefined).add(node, \"touchstart\", downIfAllowed).add(node, \"mousedown\", downIfAllowed).add(node, \"touchcancel\", up).add(node, \"contextmenu\", up).add(node, \"click\", click, true);\n    }\n    function destroy() {\n        initEvents.clear();\n        dragEvents.clear();\n    }\n    function addDragEvents() {\n        const node = isMouse ? ownerDocument : rootNode;\n        dragEvents.add(node, \"touchmove\", move, nonPassiveEvent).add(node, \"touchend\", up).add(node, \"mousemove\", move, nonPassiveEvent).add(node, \"mouseup\", up);\n    }\n    function isFocusNode(node) {\n        const nodeName = node.nodeName || \"\";\n        return focusNodes.includes(nodeName);\n    }\n    function forceBoost() {\n        const boost = dragFree ? freeForceBoost : snapForceBoost;\n        const type = isMouse ? \"mouse\" : \"touch\";\n        return boost[type];\n    }\n    function allowedForce(force, targetChanged) {\n        const next = index.add(mathSign(force) * -1);\n        const baseForce = scrollTarget.byDistance(force, !dragFree).distance;\n        if (dragFree || mathAbs(force) < goToNextThreshold) return baseForce;\n        if (skipSnaps && targetChanged) return baseForce * 0.5;\n        return scrollTarget.byIndex(next.get(), 0).distance;\n    }\n    function down(evt) {\n        const isMouseEvt = isMouseEvent(evt, ownerWindow);\n        isMouse = isMouseEvt;\n        if (isMouseEvt && evt.button !== 0) return;\n        if (isFocusNode(evt.target)) return;\n        preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving;\n        isMoving = deltaAbs(target.get(), location.get()) >= 2;\n        pointerIsDown = true;\n        dragTracker.pointerDown(evt);\n        scrollBody.useFriction(0).useDuration(0);\n        target.set(location);\n        addDragEvents();\n        startScroll = dragTracker.readPoint(evt);\n        startCross = dragTracker.readPoint(evt, crossAxis);\n        eventHandler.emit(\"pointerDown\");\n    }\n    function move(evt) {\n        const lastScroll = dragTracker.readPoint(evt);\n        const lastCross = dragTracker.readPoint(evt, crossAxis);\n        const diffScroll = deltaAbs(lastScroll, startScroll);\n        const diffCross = deltaAbs(lastCross, startCross);\n        if (!preventScroll && !isMouse) {\n            if (!evt.cancelable) return up(evt);\n            preventScroll = diffScroll > diffCross;\n            if (!preventScroll) return up(evt);\n        }\n        const diff = dragTracker.pointerMove(evt);\n        if (diffScroll > dragThreshold) preventClick = true;\n        scrollBody.useFriction(0.3).useDuration(1);\n        animation.start();\n        target.add(direction.apply(diff));\n        evt.preventDefault();\n    }\n    function up(evt) {\n        const currentLocation = scrollTarget.byDistance(0, false);\n        const targetChanged = currentLocation.index !== index.get();\n        const rawForce = dragTracker.pointerUp(evt) * forceBoost();\n        const force = allowedForce(direction.apply(rawForce), targetChanged);\n        const forceFactor = factorAbs(rawForce, force);\n        const speed = baseSpeed - 10 * forceFactor;\n        const friction = baseFriction + forceFactor / 50;\n        preventScroll = false;\n        pointerIsDown = false;\n        dragEvents.clear();\n        scrollBody.useDuration(speed).useFriction(friction);\n        scrollTo.distance(force, !dragFree);\n        isMouse = false;\n        eventHandler.emit(\"pointerUp\");\n    }\n    function click(evt) {\n        if (preventClick) {\n            evt.stopPropagation();\n            evt.preventDefault();\n        }\n    }\n    function pointerDown() {\n        return pointerIsDown;\n    }\n    const self = {\n        init,\n        pointerDown,\n        destroy\n    };\n    return self;\n}\nfunction DragTracker(axis, ownerWindow) {\n    const logInterval = 170;\n    let startEvent;\n    let lastEvent;\n    function readTime(evt) {\n        return evt.timeStamp;\n    }\n    function readPoint(evt, evtAxis) {\n        const property = evtAxis || axis.scroll;\n        const coord = `client${property === \"x\" ? \"X\" : \"Y\"}`;\n        return (isMouseEvent(evt, ownerWindow) ? evt : evt.touches[0])[coord];\n    }\n    function pointerDown(evt) {\n        startEvent = evt;\n        lastEvent = evt;\n        return readPoint(evt);\n    }\n    function pointerMove(evt) {\n        const diff = readPoint(evt) - readPoint(lastEvent);\n        const expired = readTime(evt) - readTime(startEvent) > logInterval;\n        lastEvent = evt;\n        if (expired) startEvent = evt;\n        return diff;\n    }\n    function pointerUp(evt) {\n        if (!startEvent || !lastEvent) return 0;\n        const diffDrag = readPoint(lastEvent) - readPoint(startEvent);\n        const diffTime = readTime(evt) - readTime(startEvent);\n        const expired = readTime(evt) - readTime(lastEvent) > logInterval;\n        const force = diffDrag / diffTime;\n        const isFlick = diffTime && !expired && mathAbs(force) > 0.1;\n        return isFlick ? force : 0;\n    }\n    const self = {\n        pointerDown,\n        pointerMove,\n        pointerUp,\n        readPoint\n    };\n    return self;\n}\nfunction NodeRects() {\n    function measure(node) {\n        const { offsetTop, offsetLeft, offsetWidth, offsetHeight } = node;\n        const offset = {\n            top: offsetTop,\n            right: offsetLeft + offsetWidth,\n            bottom: offsetTop + offsetHeight,\n            left: offsetLeft,\n            width: offsetWidth,\n            height: offsetHeight\n        };\n        return offset;\n    }\n    const self = {\n        measure\n    };\n    return self;\n}\nfunction PercentOfView(viewSize) {\n    function measure(n) {\n        return viewSize * (n / 100);\n    }\n    const self = {\n        measure\n    };\n    return self;\n}\nfunction ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects) {\n    let resizeObserver;\n    let containerSize;\n    let slideSizes = [];\n    let destroyed = false;\n    function readSize(node) {\n        return axis.measureSize(nodeRects.measure(node));\n    }\n    function init(emblaApi) {\n        if (!watchResize) return;\n        containerSize = readSize(container);\n        slideSizes = slides.map(readSize);\n        function defaultCallback(entries) {\n            for (const entry of entries){\n                const isContainer = entry.target === container;\n                const slideIndex = slides.indexOf(entry.target);\n                const lastSize = isContainer ? containerSize : slideSizes[slideIndex];\n                const newSize = readSize(isContainer ? container : slides[slideIndex]);\n                const diffSize = mathAbs(newSize - lastSize);\n                if (diffSize >= 0.5) {\n                    ownerWindow.requestAnimationFrame(()=>{\n                        emblaApi.reInit();\n                        eventHandler.emit(\"resize\");\n                    });\n                    break;\n                }\n            }\n        }\n        resizeObserver = new ResizeObserver((entries)=>{\n            if (destroyed) return;\n            if (isBoolean(watchResize) || watchResize(emblaApi, entries)) {\n                defaultCallback(entries);\n            }\n        });\n        const observeNodes = [\n            container\n        ].concat(slides);\n        observeNodes.forEach((node)=>resizeObserver.observe(node));\n    }\n    function destroy() {\n        if (resizeObserver) resizeObserver.disconnect();\n        destroyed = true;\n    }\n    const self = {\n        init,\n        destroy\n    };\n    return self;\n}\nfunction ScrollBody(location, offsetLocation, target, baseDuration, baseFriction) {\n    let bodyVelocity = 0;\n    let scrollDirection = 0;\n    let scrollDuration = baseDuration;\n    let scrollFriction = baseFriction;\n    let rawLocation = location.get();\n    let rawLocationPrevious = 0;\n    function seek() {\n        const diff = target.get() - location.get();\n        const isInstant = !scrollDuration;\n        let directionDiff = 0;\n        if (isInstant) {\n            bodyVelocity = 0;\n            location.set(target);\n            directionDiff = diff;\n        } else {\n            bodyVelocity += diff / scrollDuration;\n            bodyVelocity *= scrollFriction;\n            rawLocation += bodyVelocity;\n            location.add(bodyVelocity);\n            directionDiff = rawLocation - rawLocationPrevious;\n        }\n        scrollDirection = mathSign(directionDiff);\n        rawLocationPrevious = rawLocation;\n        return self;\n    }\n    function settled() {\n        const diff = target.get() - offsetLocation.get();\n        return mathAbs(diff) < 0.001;\n    }\n    function duration() {\n        return scrollDuration;\n    }\n    function direction() {\n        return scrollDirection;\n    }\n    function velocity() {\n        return bodyVelocity;\n    }\n    function useBaseDuration() {\n        return useDuration(baseDuration);\n    }\n    function useBaseFriction() {\n        return useFriction(baseFriction);\n    }\n    function useDuration(n) {\n        scrollDuration = n;\n        return self;\n    }\n    function useFriction(n) {\n        scrollFriction = n;\n        return self;\n    }\n    const self = {\n        direction,\n        duration,\n        velocity,\n        seek,\n        settled,\n        useBaseFriction,\n        useBaseDuration,\n        useFriction,\n        useDuration\n    };\n    return self;\n}\nfunction ScrollBounds(limit, location, target, scrollBody, percentOfView) {\n    const pullBackThreshold = percentOfView.measure(10);\n    const edgeOffsetTolerance = percentOfView.measure(50);\n    const frictionLimit = Limit(0.1, 0.99);\n    let disabled = false;\n    function shouldConstrain() {\n        if (disabled) return false;\n        if (!limit.reachedAny(target.get())) return false;\n        if (!limit.reachedAny(location.get())) return false;\n        return true;\n    }\n    function constrain(pointerDown) {\n        if (!shouldConstrain()) return;\n        const edge = limit.reachedMin(location.get()) ? \"min\" : \"max\";\n        const diffToEdge = mathAbs(limit[edge] - location.get());\n        const diffToTarget = target.get() - location.get();\n        const friction = frictionLimit.constrain(diffToEdge / edgeOffsetTolerance);\n        target.subtract(diffToTarget * friction);\n        if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {\n            target.set(limit.constrain(target.get()));\n            scrollBody.useDuration(25).useBaseFriction();\n        }\n    }\n    function toggleActive(active) {\n        disabled = !active;\n    }\n    const self = {\n        constrain,\n        toggleActive\n    };\n    return self;\n}\nfunction ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance) {\n    const scrollBounds = Limit(-contentSize + viewSize, 0);\n    const snapsBounded = measureBounded();\n    const scrollContainLimit = findScrollContainLimit();\n    const snapsContained = measureContained();\n    function findScrollContainLimit() {\n        const startSnap = snapsBounded[0];\n        const endSnap = arrayLast(snapsBounded);\n        const min = snapsBounded.lastIndexOf(startSnap);\n        const max = snapsBounded.indexOf(endSnap) + 1;\n        return Limit(min, max);\n    }\n    function measureBounded() {\n        return snapsAligned.map((snapAligned, index)=>{\n            const isFirst = !index;\n            const isLast = arrayIsLastIndex(snapsAligned, index);\n            if (isFirst) return scrollBounds.max;\n            if (isLast) return scrollBounds.min;\n            return scrollBounds.constrain(snapAligned);\n        }).map((scrollBound)=>parseFloat(scrollBound.toFixed(3)));\n    }\n    function measureContained() {\n        if (contentSize <= viewSize + pixelTolerance) return [\n            scrollBounds.max\n        ];\n        if (containScroll === \"keepSnaps\") return snapsBounded;\n        const { min, max } = scrollContainLimit;\n        return snapsBounded.slice(min, max);\n    }\n    const self = {\n        snapsContained,\n        scrollContainLimit\n    };\n    return self;\n}\nfunction ScrollLimit(contentSize, scrollSnaps, loop) {\n    const max = scrollSnaps[0];\n    const min = loop ? max - contentSize : arrayLast(scrollSnaps);\n    const limit = Limit(min, max);\n    const self = {\n        limit\n    };\n    return self;\n}\nfunction ScrollLooper(contentSize, limit, offsetLocation, vectors) {\n    const jointSafety = 0.1;\n    const min = limit.min + jointSafety;\n    const max = limit.max + jointSafety;\n    const { reachedMin, reachedMax } = Limit(min, max);\n    function shouldLoop(direction) {\n        if (direction === 1) return reachedMax(offsetLocation.get());\n        if (direction === -1) return reachedMin(offsetLocation.get());\n        return false;\n    }\n    function loop(direction) {\n        if (!shouldLoop(direction)) return;\n        const loopDistance = contentSize * (direction * -1);\n        vectors.forEach((v)=>v.add(loopDistance));\n    }\n    const self = {\n        loop\n    };\n    return self;\n}\nfunction ScrollProgress(limit) {\n    const { max, length } = limit;\n    function get(n) {\n        const currentLocation = n - max;\n        return length ? currentLocation / -length : 0;\n    }\n    const self = {\n        get\n    };\n    return self;\n}\nfunction ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll) {\n    const { startEdge, endEdge } = axis;\n    const { groupSlides } = slidesToScroll;\n    const alignments = measureSizes().map(alignment.measure);\n    const snaps = measureUnaligned();\n    const snapsAligned = measureAligned();\n    function measureSizes() {\n        return groupSlides(slideRects).map((rects)=>arrayLast(rects)[endEdge] - rects[0][startEdge]).map(mathAbs);\n    }\n    function measureUnaligned() {\n        return slideRects.map((rect)=>containerRect[startEdge] - rect[startEdge]).map((snap)=>-mathAbs(snap));\n    }\n    function measureAligned() {\n        return groupSlides(snaps).map((g)=>g[0]).map((snap, index)=>snap + alignments[index]);\n    }\n    const self = {\n        snaps,\n        snapsAligned\n    };\n    return self;\n}\nfunction SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes) {\n    const { groupSlides } = slidesToScroll;\n    const { min, max } = scrollContainLimit;\n    const slideRegistry = createSlideRegistry();\n    function createSlideRegistry() {\n        const groupedSlideIndexes = groupSlides(slideIndexes);\n        const doNotContain = !containSnaps || containScroll === \"keepSnaps\";\n        if (scrollSnaps.length === 1) return [\n            slideIndexes\n        ];\n        if (doNotContain) return groupedSlideIndexes;\n        return groupedSlideIndexes.slice(min, max).map((group, index, groups)=>{\n            const isFirst = !index;\n            const isLast = arrayIsLastIndex(groups, index);\n            if (isFirst) {\n                const range = arrayLast(groups[0]) + 1;\n                return arrayFromNumber(range);\n            }\n            if (isLast) {\n                const range = arrayLastIndex(slideIndexes) - arrayLast(groups)[0] + 1;\n                return arrayFromNumber(range, arrayLast(groups)[0]);\n            }\n            return group;\n        });\n    }\n    const self = {\n        slideRegistry\n    };\n    return self;\n}\nfunction ScrollTarget(loop, scrollSnaps, contentSize, limit, targetVector) {\n    const { reachedAny, removeOffset, constrain } = limit;\n    function minDistance(distances) {\n        return distances.concat().sort((a, b)=>mathAbs(a) - mathAbs(b))[0];\n    }\n    function findTargetSnap(target) {\n        const distance = loop ? removeOffset(target) : constrain(target);\n        const ascDiffsToSnaps = scrollSnaps.map((scrollSnap)=>scrollSnap - distance).map((diffToSnap)=>shortcut(diffToSnap, 0)).map((diff, i)=>({\n                diff,\n                index: i\n            })).sort((d1, d2)=>mathAbs(d1.diff) - mathAbs(d2.diff));\n        const { index } = ascDiffsToSnaps[0];\n        return {\n            index,\n            distance\n        };\n    }\n    function shortcut(target, direction) {\n        const targets = [\n            target,\n            target + contentSize,\n            target - contentSize\n        ];\n        if (!loop) return targets[0];\n        if (!direction) return minDistance(targets);\n        const matchingTargets = targets.filter((t)=>mathSign(t) === direction);\n        if (matchingTargets.length) return minDistance(matchingTargets);\n        return arrayLast(targets) - contentSize;\n    }\n    function byIndex(index, direction) {\n        const diffToSnap = scrollSnaps[index] - targetVector.get();\n        const distance = shortcut(diffToSnap, direction);\n        return {\n            index,\n            distance\n        };\n    }\n    function byDistance(distance, snap) {\n        const target = targetVector.get() + distance;\n        const { index, distance: targetSnapDistance } = findTargetSnap(target);\n        const reachedBound = !loop && reachedAny(target);\n        if (!snap || reachedBound) return {\n            index,\n            distance\n        };\n        const diffToSnap = scrollSnaps[index] - targetSnapDistance;\n        const snapDistance = distance + shortcut(diffToSnap, 0);\n        return {\n            index,\n            distance: snapDistance\n        };\n    }\n    const self = {\n        byDistance,\n        byIndex,\n        shortcut\n    };\n    return self;\n}\nfunction ScrollTo(animation, indexCurrent, indexPrevious, scrollBody, scrollTarget, targetVector, eventHandler) {\n    function scrollTo(target) {\n        const distanceDiff = target.distance;\n        const indexDiff = target.index !== indexCurrent.get();\n        targetVector.add(distanceDiff);\n        if (distanceDiff) {\n            if (scrollBody.duration()) {\n                animation.start();\n            } else {\n                animation.update();\n                animation.render(1);\n                animation.update();\n            }\n        }\n        if (indexDiff) {\n            indexPrevious.set(indexCurrent.get());\n            indexCurrent.set(target.index);\n            eventHandler.emit(\"select\");\n        }\n    }\n    function distance(n, snap) {\n        const target = scrollTarget.byDistance(n, snap);\n        scrollTo(target);\n    }\n    function index(n, direction) {\n        const targetIndex = indexCurrent.clone().set(n);\n        const target = scrollTarget.byIndex(targetIndex.get(), direction);\n        scrollTo(target);\n    }\n    const self = {\n        distance,\n        index\n    };\n    return self;\n}\nfunction SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore) {\n    let lastTabPressTime = 0;\n    function init() {\n        eventStore.add(document, \"keydown\", registerTabPress, false);\n        slides.forEach(addSlideFocusEvent);\n    }\n    function registerTabPress(event) {\n        if (event.code === \"Tab\") lastTabPressTime = new Date().getTime();\n    }\n    function addSlideFocusEvent(slide) {\n        const focus = ()=>{\n            const nowTime = new Date().getTime();\n            const diffTime = nowTime - lastTabPressTime;\n            if (diffTime > 10) return;\n            root.scrollLeft = 0;\n            const index = slides.indexOf(slide);\n            const group = slideRegistry.findIndex((group)=>group.includes(index));\n            if (!isNumber(group)) return;\n            scrollBody.useDuration(0);\n            scrollTo.index(group, 0);\n        };\n        eventStore.add(slide, \"focus\", focus, {\n            passive: true,\n            capture: true\n        });\n    }\n    const self = {\n        init\n    };\n    return self;\n}\nfunction Vector1D(initialValue) {\n    let value = initialValue;\n    function get() {\n        return value;\n    }\n    function set(n) {\n        value = normalizeInput(n);\n    }\n    function add(n) {\n        value += normalizeInput(n);\n    }\n    function subtract(n) {\n        value -= normalizeInput(n);\n    }\n    function normalizeInput(n) {\n        return isNumber(n) ? n : n.get();\n    }\n    const self = {\n        get,\n        set,\n        add,\n        subtract\n    };\n    return self;\n}\nfunction Translate(axis, direction, container) {\n    const translate = axis.scroll === \"x\" ? x : y;\n    const containerStyle = container.style;\n    let disabled = false;\n    function x(n) {\n        return `translate3d(${n}px,0px,0px)`;\n    }\n    function y(n) {\n        return `translate3d(0px,${n}px,0px)`;\n    }\n    function to(target) {\n        if (disabled) return;\n        containerStyle.transform = translate(direction.apply(target));\n    }\n    function toggleActive(active) {\n        disabled = !active;\n    }\n    function clear() {\n        if (disabled) return;\n        containerStyle.transform = \"\";\n        if (!container.getAttribute(\"style\")) container.removeAttribute(\"style\");\n    }\n    const self = {\n        clear,\n        to,\n        toggleActive\n    };\n    return self;\n}\nfunction SlideLooper(axis, direction, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, offsetLocation, slides) {\n    const roundingSafety = 0.5;\n    const ascItems = arrayKeys(slideSizesWithGaps);\n    const descItems = arrayKeys(slideSizesWithGaps).reverse();\n    const loopPoints = startPoints().concat(endPoints());\n    function removeSlideSizes(indexes, from) {\n        return indexes.reduce((a, i)=>{\n            return a - slideSizesWithGaps[i];\n        }, from);\n    }\n    function slidesInGap(indexes, gap) {\n        return indexes.reduce((a, i)=>{\n            const remainingGap = removeSlideSizes(a, gap);\n            return remainingGap > 0 ? a.concat([\n                i\n            ]) : a;\n        }, []);\n    }\n    function findSlideBounds(offset) {\n        return snaps.map((snap, index)=>({\n                start: snap - slideSizes[index] + roundingSafety + offset,\n                end: snap + viewSize - roundingSafety + offset\n            }));\n    }\n    function findLoopPoints(indexes, offset, isEndEdge) {\n        const slideBounds = findSlideBounds(offset);\n        return indexes.map((index)=>{\n            const initial = isEndEdge ? 0 : -contentSize;\n            const altered = isEndEdge ? contentSize : 0;\n            const boundEdge = isEndEdge ? \"end\" : \"start\";\n            const loopPoint = slideBounds[index][boundEdge];\n            return {\n                index,\n                loopPoint,\n                slideLocation: Vector1D(-1),\n                translate: Translate(axis, direction, slides[index]),\n                target: ()=>offsetLocation.get() > loopPoint ? initial : altered\n            };\n        });\n    }\n    function startPoints() {\n        const gap = scrollSnaps[0];\n        const indexes = slidesInGap(descItems, gap);\n        return findLoopPoints(indexes, contentSize, false);\n    }\n    function endPoints() {\n        const gap = viewSize - scrollSnaps[0] - 1;\n        const indexes = slidesInGap(ascItems, gap);\n        return findLoopPoints(indexes, -contentSize, true);\n    }\n    function canLoop() {\n        return loopPoints.every(({ index })=>{\n            const otherIndexes = ascItems.filter((i)=>i !== index);\n            return removeSlideSizes(otherIndexes, viewSize) <= 0.1;\n        });\n    }\n    function loop() {\n        loopPoints.forEach((loopPoint)=>{\n            const { target, translate, slideLocation } = loopPoint;\n            const shiftLocation = target();\n            if (shiftLocation === slideLocation.get()) return;\n            translate.to(shiftLocation);\n            slideLocation.set(shiftLocation);\n        });\n    }\n    function clear() {\n        loopPoints.forEach((loopPoint)=>loopPoint.translate.clear());\n    }\n    const self = {\n        canLoop,\n        clear,\n        loop,\n        loopPoints\n    };\n    return self;\n}\nfunction SlidesHandler(container, eventHandler, watchSlides) {\n    let mutationObserver;\n    let destroyed = false;\n    function init(emblaApi) {\n        if (!watchSlides) return;\n        function defaultCallback(mutations) {\n            for (const mutation of mutations){\n                if (mutation.type === \"childList\") {\n                    emblaApi.reInit();\n                    eventHandler.emit(\"slidesChanged\");\n                    break;\n                }\n            }\n        }\n        mutationObserver = new MutationObserver((mutations)=>{\n            if (destroyed) return;\n            if (isBoolean(watchSlides) || watchSlides(emblaApi, mutations)) {\n                defaultCallback(mutations);\n            }\n        });\n        mutationObserver.observe(container, {\n            childList: true\n        });\n    }\n    function destroy() {\n        if (mutationObserver) mutationObserver.disconnect();\n        destroyed = true;\n    }\n    const self = {\n        init,\n        destroy\n    };\n    return self;\n}\nfunction SlidesInView(container, slides, eventHandler, threshold) {\n    const intersectionEntryMap = {};\n    let inViewCache = null;\n    let notInViewCache = null;\n    let intersectionObserver;\n    let destroyed = false;\n    function init() {\n        intersectionObserver = new IntersectionObserver((entries)=>{\n            if (destroyed) return;\n            entries.forEach((entry)=>{\n                const index = slides.indexOf(entry.target);\n                intersectionEntryMap[index] = entry;\n            });\n            inViewCache = null;\n            notInViewCache = null;\n            eventHandler.emit(\"slidesInView\");\n        }, {\n            root: container.parentElement,\n            threshold\n        });\n        slides.forEach((slide)=>intersectionObserver.observe(slide));\n    }\n    function destroy() {\n        if (intersectionObserver) intersectionObserver.disconnect();\n        destroyed = true;\n    }\n    function createInViewList(inView) {\n        return objectKeys(intersectionEntryMap).reduce((list, slideIndex)=>{\n            const index = parseInt(slideIndex);\n            const { isIntersecting } = intersectionEntryMap[index];\n            const inViewMatch = inView && isIntersecting;\n            const notInViewMatch = !inView && !isIntersecting;\n            if (inViewMatch || notInViewMatch) list.push(index);\n            return list;\n        }, []);\n    }\n    function get(inView = true) {\n        if (inView && inViewCache) return inViewCache;\n        if (!inView && notInViewCache) return notInViewCache;\n        const slideIndexes = createInViewList(inView);\n        if (inView) inViewCache = slideIndexes;\n        if (!inView) notInViewCache = slideIndexes;\n        return slideIndexes;\n    }\n    const self = {\n        init,\n        destroy,\n        get\n    };\n    return self;\n}\nfunction SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow) {\n    const { measureSize, startEdge, endEdge } = axis;\n    const withEdgeGap = slideRects[0] && readEdgeGap;\n    const startGap = measureStartGap();\n    const endGap = measureEndGap();\n    const slideSizes = slideRects.map(measureSize);\n    const slideSizesWithGaps = measureWithGaps();\n    function measureStartGap() {\n        if (!withEdgeGap) return 0;\n        const slideRect = slideRects[0];\n        return mathAbs(containerRect[startEdge] - slideRect[startEdge]);\n    }\n    function measureEndGap() {\n        if (!withEdgeGap) return 0;\n        const style = ownerWindow.getComputedStyle(arrayLast(slides));\n        return parseFloat(style.getPropertyValue(`margin-${endEdge}`));\n    }\n    function measureWithGaps() {\n        return slideRects.map((rect, index, rects)=>{\n            const isFirst = !index;\n            const isLast = arrayIsLastIndex(rects, index);\n            if (isFirst) return slideSizes[index] + startGap;\n            if (isLast) return slideSizes[index] + endGap;\n            return rects[index + 1][startEdge] - rect[startEdge];\n        }).map(mathAbs);\n    }\n    const self = {\n        slideSizes,\n        slideSizesWithGaps,\n        startGap,\n        endGap\n    };\n    return self;\n}\nfunction SlidesToScroll(axis, direction, viewSize, slidesToScroll, loop, containerRect, slideRects, startGap, endGap, pixelTolerance) {\n    const { startEdge, endEdge } = axis;\n    const groupByNumber = isNumber(slidesToScroll);\n    function byNumber(array, groupSize) {\n        return arrayKeys(array).filter((i)=>i % groupSize === 0).map((i)=>array.slice(i, i + groupSize));\n    }\n    function bySize(array) {\n        if (!array.length) return [];\n        return arrayKeys(array).reduce((groups, rectB)=>{\n            const rectA = arrayLast(groups) || 0;\n            const isFirst = rectA === 0;\n            const isLast = rectB === arrayLastIndex(array);\n            const edgeA = containerRect[startEdge] - slideRects[rectA][startEdge];\n            const edgeB = containerRect[startEdge] - slideRects[rectB][endEdge];\n            const gapA = !loop && isFirst ? direction.apply(startGap) : 0;\n            const gapB = !loop && isLast ? direction.apply(endGap) : 0;\n            const chunkSize = mathAbs(edgeB - gapB - (edgeA + gapA));\n            if (chunkSize > viewSize + pixelTolerance) groups.push(rectB);\n            if (isLast) groups.push(array.length);\n            return groups;\n        }, []).map((currentSize, index, groups)=>{\n            const previousSize = Math.max(groups[index - 1] || 0);\n            return array.slice(previousSize, currentSize);\n        });\n    }\n    function groupSlides(array) {\n        return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array);\n    }\n    const self = {\n        groupSlides\n    };\n    return self;\n}\nfunction Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler) {\n    // Options\n    const { align, axis: scrollAxis, direction: contentDirection, startIndex, loop, duration, dragFree, dragThreshold, inViewThreshold, slidesToScroll: groupSlides, skipSnaps, containScroll, watchResize, watchSlides, watchDrag } = options;\n    // Measurements\n    const pixelTolerance = 2;\n    const nodeRects = NodeRects();\n    const containerRect = nodeRects.measure(container);\n    const slideRects = slides.map(nodeRects.measure);\n    const direction = Direction(contentDirection);\n    const axis = Axis(scrollAxis, contentDirection);\n    const viewSize = axis.measureSize(containerRect);\n    const percentOfView = PercentOfView(viewSize);\n    const alignment = Alignment(align, viewSize);\n    const containSnaps = !loop && !!containScroll;\n    const readEdgeGap = loop || !!containScroll;\n    const { slideSizes, slideSizesWithGaps, startGap, endGap } = SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow);\n    const slidesToScroll = SlidesToScroll(axis, direction, viewSize, groupSlides, loop, containerRect, slideRects, startGap, endGap, pixelTolerance);\n    const { snaps, snapsAligned } = ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll);\n    const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);\n    const { snapsContained, scrollContainLimit } = ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance);\n    const scrollSnaps = containSnaps ? snapsContained : snapsAligned;\n    const { limit } = ScrollLimit(contentSize, scrollSnaps, loop);\n    // Indexes\n    const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop);\n    const indexPrevious = index.clone();\n    const slideIndexes = arrayKeys(slides);\n    // Animation\n    const update = ({ dragHandler, scrollBody, scrollBounds, options: { loop } })=>{\n        if (!loop) scrollBounds.constrain(dragHandler.pointerDown());\n        scrollBody.seek();\n    };\n    const render = ({ scrollBody, translate, location, offsetLocation, scrollLooper, slideLooper, dragHandler, animation, eventHandler, options: { loop } }, lagOffset)=>{\n        const velocity = scrollBody.velocity();\n        const hasSettled = scrollBody.settled();\n        if (hasSettled && !dragHandler.pointerDown()) {\n            animation.stop();\n            eventHandler.emit(\"settle\");\n        }\n        if (!hasSettled) eventHandler.emit(\"scroll\");\n        offsetLocation.set(location.get() - velocity + velocity * lagOffset);\n        if (loop) {\n            scrollLooper.loop(scrollBody.direction());\n            slideLooper.loop();\n        }\n        translate.to(offsetLocation.get());\n    };\n    const animation = Animations(ownerDocument, ownerWindow, ()=>update(engine), (lagOffset)=>render(engine, lagOffset));\n    // Shared\n    const friction = 0.68;\n    const startLocation = scrollSnaps[index.get()];\n    const location = Vector1D(startLocation);\n    const offsetLocation = Vector1D(startLocation);\n    const target = Vector1D(startLocation);\n    const scrollBody = ScrollBody(location, offsetLocation, target, duration, friction);\n    const scrollTarget = ScrollTarget(loop, scrollSnaps, contentSize, limit, target);\n    const scrollTo = ScrollTo(animation, index, indexPrevious, scrollBody, scrollTarget, target, eventHandler);\n    const scrollProgress = ScrollProgress(limit);\n    const eventStore = EventStore();\n    const slidesInView = SlidesInView(container, slides, eventHandler, inViewThreshold);\n    const { slideRegistry } = SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes);\n    const slideFocus = SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore);\n    // Engine\n    const engine = {\n        ownerDocument,\n        ownerWindow,\n        eventHandler,\n        containerRect,\n        slideRects,\n        animation,\n        axis,\n        direction,\n        dragHandler: DragHandler(axis, direction, root, ownerDocument, ownerWindow, target, DragTracker(axis, ownerWindow), location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, friction, watchDrag),\n        eventStore,\n        percentOfView,\n        index,\n        indexPrevious,\n        limit,\n        location,\n        offsetLocation,\n        options,\n        resizeHandler: ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects),\n        scrollBody,\n        scrollBounds: ScrollBounds(limit, location, target, scrollBody, percentOfView),\n        scrollLooper: ScrollLooper(contentSize, limit, offsetLocation, [\n            location,\n            offsetLocation,\n            target\n        ]),\n        scrollProgress,\n        scrollSnapList: scrollSnaps.map(scrollProgress.get),\n        scrollSnaps,\n        scrollTarget,\n        scrollTo,\n        slideLooper: SlideLooper(axis, direction, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, offsetLocation, slides),\n        slideFocus,\n        slidesHandler: SlidesHandler(container, eventHandler, watchSlides),\n        slidesInView,\n        slideIndexes,\n        slideRegistry,\n        slidesToScroll,\n        target,\n        translate: Translate(axis, direction, container)\n    };\n    return engine;\n}\nfunction EventHandler() {\n    const listeners = {};\n    let api;\n    function init(emblaApi) {\n        api = emblaApi;\n    }\n    function getListeners(evt) {\n        return listeners[evt] || [];\n    }\n    function emit(evt) {\n        getListeners(evt).forEach((e)=>e(api, evt));\n        return self;\n    }\n    function on(evt, cb) {\n        listeners[evt] = getListeners(evt).concat([\n            cb\n        ]);\n        return self;\n    }\n    function off(evt, cb) {\n        listeners[evt] = getListeners(evt).filter((e)=>e !== cb);\n        return self;\n    }\n    const self = {\n        init,\n        emit,\n        off,\n        on\n    };\n    return self;\n}\nconst defaultOptions = {\n    align: \"center\",\n    axis: \"x\",\n    container: null,\n    slides: null,\n    containScroll: \"trimSnaps\",\n    direction: \"ltr\",\n    slidesToScroll: 1,\n    inViewThreshold: 0,\n    breakpoints: {},\n    dragFree: false,\n    dragThreshold: 10,\n    loop: false,\n    skipSnaps: false,\n    duration: 25,\n    startIndex: 0,\n    active: true,\n    watchDrag: true,\n    watchResize: true,\n    watchSlides: true\n};\nfunction OptionsHandler(ownerWindow) {\n    function mergeOptions(optionsA, optionsB) {\n        return objectsMergeDeep(optionsA, optionsB || {});\n    }\n    function optionsAtMedia(options) {\n        const optionsAtMedia = options.breakpoints || {};\n        const matchedMediaOptions = objectKeys(optionsAtMedia).filter((media)=>ownerWindow.matchMedia(media).matches).map((media)=>optionsAtMedia[media]).reduce((a, mediaOption)=>mergeOptions(a, mediaOption), {});\n        return mergeOptions(options, matchedMediaOptions);\n    }\n    function optionsMediaQueries(optionsList) {\n        return optionsList.map((options)=>objectKeys(options.breakpoints || {})).reduce((acc, mediaQueries)=>acc.concat(mediaQueries), []).map(ownerWindow.matchMedia);\n    }\n    const self = {\n        mergeOptions,\n        optionsAtMedia,\n        optionsMediaQueries\n    };\n    return self;\n}\nfunction PluginsHandler(optionsHandler) {\n    let activePlugins = [];\n    function init(emblaApi, plugins) {\n        activePlugins = plugins.filter(({ options })=>optionsHandler.optionsAtMedia(options).active !== false);\n        activePlugins.forEach((plugin)=>plugin.init(emblaApi, optionsHandler));\n        return plugins.reduce((map, plugin)=>Object.assign(map, {\n                [plugin.name]: plugin\n            }), {});\n    }\n    function destroy() {\n        activePlugins = activePlugins.filter((plugin)=>plugin.destroy());\n    }\n    const self = {\n        init,\n        destroy\n    };\n    return self;\n}\nfunction EmblaCarousel(root, userOptions, userPlugins) {\n    const ownerDocument = root.ownerDocument;\n    const ownerWindow = ownerDocument.defaultView;\n    const optionsHandler = OptionsHandler(ownerWindow);\n    const pluginsHandler = PluginsHandler(optionsHandler);\n    const mediaHandlers = EventStore();\n    const eventHandler = EventHandler();\n    const { mergeOptions, optionsAtMedia, optionsMediaQueries } = optionsHandler;\n    const { on, off, emit } = eventHandler;\n    const reInit = reActivate;\n    let destroyed = false;\n    let engine;\n    let optionsBase = mergeOptions(defaultOptions, EmblaCarousel.globalOptions);\n    let options = mergeOptions(optionsBase);\n    let pluginList = [];\n    let pluginApis;\n    let container;\n    let slides;\n    function storeElements() {\n        const { container: userContainer, slides: userSlides } = options;\n        const customContainer = isString(userContainer) ? root.querySelector(userContainer) : userContainer;\n        container = customContainer || root.children[0];\n        const customSlides = isString(userSlides) ? container.querySelectorAll(userSlides) : userSlides;\n        slides = [].slice.call(customSlides || container.children);\n    }\n    function createEngine(options) {\n        const engine = Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler);\n        if (options.loop && !engine.slideLooper.canLoop()) {\n            const optionsWithoutLoop = Object.assign({}, options, {\n                loop: false\n            });\n            return createEngine(optionsWithoutLoop);\n        }\n        return engine;\n    }\n    function activate(withOptions, withPlugins) {\n        if (destroyed) return;\n        optionsBase = mergeOptions(optionsBase, withOptions);\n        options = optionsAtMedia(optionsBase);\n        pluginList = withPlugins || pluginList;\n        storeElements();\n        engine = createEngine(options);\n        optionsMediaQueries([\n            optionsBase,\n            ...pluginList.map(({ options })=>options)\n        ]).forEach((query)=>mediaHandlers.add(query, \"change\", reActivate));\n        if (!options.active) return;\n        engine.translate.to(engine.location.get());\n        engine.animation.init();\n        engine.slidesInView.init();\n        engine.slideFocus.init();\n        engine.eventHandler.init(self);\n        engine.resizeHandler.init(self);\n        engine.slidesHandler.init(self);\n        if (engine.options.loop) engine.slideLooper.loop();\n        if (container.offsetParent && slides.length) engine.dragHandler.init(self);\n        pluginApis = pluginsHandler.init(self, pluginList);\n    }\n    function reActivate(withOptions, withPlugins) {\n        const startIndex = selectedScrollSnap();\n        deActivate();\n        activate(mergeOptions({\n            startIndex\n        }, withOptions), withPlugins);\n        eventHandler.emit(\"reInit\");\n    }\n    function deActivate() {\n        engine.dragHandler.destroy();\n        engine.eventStore.clear();\n        engine.translate.clear();\n        engine.slideLooper.clear();\n        engine.resizeHandler.destroy();\n        engine.slidesHandler.destroy();\n        engine.slidesInView.destroy();\n        engine.animation.destroy();\n        pluginsHandler.destroy();\n        mediaHandlers.clear();\n    }\n    function destroy() {\n        if (destroyed) return;\n        destroyed = true;\n        mediaHandlers.clear();\n        deActivate();\n        eventHandler.emit(\"destroy\");\n    }\n    function scrollTo(index, jump, direction) {\n        if (!options.active || destroyed) return;\n        engine.scrollBody.useBaseFriction().useDuration(jump === true ? 0 : options.duration);\n        engine.scrollTo.index(index, direction || 0);\n    }\n    function scrollNext(jump) {\n        const next = engine.index.add(1).get();\n        scrollTo(next, jump, -1);\n    }\n    function scrollPrev(jump) {\n        const prev = engine.index.add(-1).get();\n        scrollTo(prev, jump, 1);\n    }\n    function canScrollNext() {\n        const next = engine.index.add(1).get();\n        return next !== selectedScrollSnap();\n    }\n    function canScrollPrev() {\n        const prev = engine.index.add(-1).get();\n        return prev !== selectedScrollSnap();\n    }\n    function scrollSnapList() {\n        return engine.scrollSnapList;\n    }\n    function scrollProgress() {\n        return engine.scrollProgress.get(engine.location.get());\n    }\n    function selectedScrollSnap() {\n        return engine.index.get();\n    }\n    function previousScrollSnap() {\n        return engine.indexPrevious.get();\n    }\n    function slidesInView() {\n        return engine.slidesInView.get();\n    }\n    function slidesNotInView() {\n        return engine.slidesInView.get(false);\n    }\n    function plugins() {\n        return pluginApis;\n    }\n    function internalEngine() {\n        return engine;\n    }\n    function rootNode() {\n        return root;\n    }\n    function containerNode() {\n        return container;\n    }\n    function slideNodes() {\n        return slides;\n    }\n    const self = {\n        canScrollNext,\n        canScrollPrev,\n        containerNode,\n        internalEngine,\n        destroy,\n        off,\n        on,\n        emit,\n        plugins,\n        previousScrollSnap,\n        reInit,\n        rootNode,\n        scrollNext,\n        scrollPrev,\n        scrollProgress,\n        scrollSnapList,\n        scrollTo,\n        selectedScrollSnap,\n        slideNodes,\n        slidesInView,\n        slidesNotInView\n    };\n    activate(userOptions, userPlugins);\n    setTimeout(()=>eventHandler.emit(\"init\"), 0);\n    return self;\n}\nEmblaCarousel.globalOptions = undefined;\n //# sourceMappingURL=embla-carousel.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZW1ibGEtY2Fyb3VzZWwvZXNtL2VtYmxhLWNhcm91c2VsLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsU0FBU0EsU0FBU0MsT0FBTztJQUN2QixPQUFPLE9BQU9BLFlBQVk7QUFDNUI7QUFDQSxTQUFTQyxTQUFTRCxPQUFPO0lBQ3ZCLE9BQU8sT0FBT0EsWUFBWTtBQUM1QjtBQUNBLFNBQVNFLFVBQVVGLE9BQU87SUFDeEIsT0FBTyxPQUFPQSxZQUFZO0FBQzVCO0FBQ0EsU0FBU0csU0FBU0gsT0FBTztJQUN2QixPQUFPSSxPQUFPQyxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDUCxhQUFhO0FBQ3JEO0FBQ0EsU0FBU1EsUUFBUUMsQ0FBQztJQUNoQixPQUFPQyxLQUFLQyxHQUFHLENBQUNGO0FBQ2xCO0FBQ0EsU0FBU0csU0FBU0gsQ0FBQztJQUNqQixPQUFPQyxLQUFLRyxJQUFJLENBQUNKO0FBQ25CO0FBQ0EsU0FBU0ssU0FBU0MsTUFBTSxFQUFFQyxNQUFNO0lBQzlCLE9BQU9SLFFBQVFPLFNBQVNDO0FBQzFCO0FBQ0EsU0FBU0MsVUFBVUYsTUFBTSxFQUFFQyxNQUFNO0lBQy9CLElBQUlELFdBQVcsS0FBS0MsV0FBVyxHQUFHLE9BQU87SUFDekMsSUFBSVIsUUFBUU8sV0FBV1AsUUFBUVEsU0FBUyxPQUFPO0lBQy9DLE1BQU1FLE9BQU9KLFNBQVNOLFFBQVFPLFNBQVNQLFFBQVFRO0lBQy9DLE9BQU9SLFFBQVFVLE9BQU9IO0FBQ3hCO0FBQ0EsU0FBU0ksVUFBVUMsS0FBSztJQUN0QixPQUFPQyxXQUFXRCxPQUFPRSxHQUFHLENBQUNDO0FBQy9CO0FBQ0EsU0FBU0MsVUFBVUosS0FBSztJQUN0QixPQUFPQSxLQUFLLENBQUNLLGVBQWVMLE9BQU87QUFDckM7QUFDQSxTQUFTSyxlQUFlTCxLQUFLO0lBQzNCLE9BQU9WLEtBQUtnQixHQUFHLENBQUMsR0FBR04sTUFBTU8sTUFBTSxHQUFHO0FBQ3BDO0FB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dVk7UUFDUCxPQUFPYztJQUNUO0lBQ0EsU0FBUzBCO1FBQ1AsT0FBTzFFO0lBQ1Q7SUFDQSxTQUFTL1Y7UUFDUCxPQUFPOE87SUFDVDtJQUNBLFNBQVM0TDtRQUNQLE9BQU9yVTtJQUNUO0lBQ0EsU0FBU3NVO1FBQ1AsT0FBT3JVO0lBQ1Q7SUFDQSxNQUFNNUssT0FBTztRQUNYMmU7UUFDQUM7UUFDQUk7UUFDQUQ7UUFDQWpkO1FBQ0FxWjtRQUNBRjtRQUNBN1M7UUFDQW1VO1FBQ0FzQztRQUNBaFQ7UUFDQXZIO1FBQ0FrYTtRQUNBQztRQUNBbEU7UUFDQUk7UUFDQWhXO1FBQ0EwWjtRQUNBWTtRQUNBekU7UUFDQXNFO0lBQ0Y7SUFDQWQsU0FBU3BCLGFBQWFDO0lBQ3RCcUMsV0FBVyxJQUFNcGEsYUFBYXNELElBQUksQ0FBQyxTQUFTO0lBQzVDLE9BQU9wSTtBQUNUO0FBQ0EyYyxjQUFjUSxhQUFhLEdBQUd4VztBQUVNLENBQ3BDLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL2F1dG9zLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL2VtYmxhLWNhcm91c2VsL2VzbS9lbWJsYS1jYXJvdXNlbC5lc20uanM/MmQ4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBpc051bWJlcihzdWJqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygc3ViamVjdCA9PT0gJ251bWJlcic7XG59XG5mdW5jdGlvbiBpc1N0cmluZyhzdWJqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygc3ViamVjdCA9PT0gJ3N0cmluZyc7XG59XG5mdW5jdGlvbiBpc0Jvb2xlYW4oc3ViamVjdCkge1xuICByZXR1cm4gdHlwZW9mIHN1YmplY3QgPT09ICdib29sZWFuJztcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHN1YmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdWJqZWN0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5mdW5jdGlvbiBtYXRoQWJzKG4pIHtcbiAgcmV0dXJuIE1hdGguYWJzKG4pO1xufVxuZnVuY3Rpb24gbWF0aFNpZ24obikge1xuICByZXR1cm4gTWF0aC5zaWduKG4pO1xufVxuZnVuY3Rpb24gZGVsdGFBYnModmFsdWVCLCB2YWx1ZUEpIHtcbiAgcmV0dXJuIG1hdGhBYnModmFsdWVCIC0gdmFsdWVBKTtcbn1cbmZ1bmN0aW9uIGZhY3RvckFicyh2YWx1ZUIsIHZhbHVlQSkge1xuICBpZiAodmFsdWVCID09PSAwIHx8IHZhbHVlQSA9PT0gMCkgcmV0dXJuIDA7XG4gIGlmIChtYXRoQWJzKHZhbHVlQikgPD0gbWF0aEFicyh2YWx1ZUEpKSByZXR1cm4gMDtcbiAgY29uc3QgZGlmZiA9IGRlbHRhQWJzKG1hdGhBYnModmFsdWVCKSwgbWF0aEFicyh2YWx1ZUEpKTtcbiAgcmV0dXJuIG1hdGhBYnMoZGlmZiAvIHZhbHVlQik7XG59XG5mdW5jdGlvbiBhcnJheUtleXMoYXJyYXkpIHtcbiAgcmV0dXJuIG9iamVjdEtleXMoYXJyYXkpLm1hcChOdW1iZXIpO1xufVxuZnVuY3Rpb24gYXJyYXlMYXN0KGFycmF5KSB7XG4gIHJldHVybiBhcnJheVthcnJheUxhc3RJbmRleChhcnJheSldO1xufVxuZnVuY3Rpb24gYXJyYXlMYXN0SW5kZXgoYXJyYXkpIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIDEpO1xufVxuZnVuY3Rpb24gYXJyYXlJc0xhc3RJbmRleChhcnJheSwgaW5kZXgpIHtcbiAgcmV0dXJuIGluZGV4ID09PSBhcnJheUxhc3RJbmRleChhcnJheSk7XG59XG5mdW5jdGlvbiBhcnJheUZyb21OdW1iZXIobiwgc3RhcnRBdCA9IDApIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oQXJyYXkobiksIChfLCBpKSA9PiBzdGFydEF0ICsgaSk7XG59XG5mdW5jdGlvbiBvYmplY3RLZXlzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqZWN0KTtcbn1cbmZ1bmN0aW9uIG9iamVjdHNNZXJnZURlZXAob2JqZWN0QSwgb2JqZWN0Qikge1xuICByZXR1cm4gW29iamVjdEEsIG9iamVjdEJdLnJlZHVjZSgobWVyZ2VkT2JqZWN0cywgY3VycmVudE9iamVjdCkgPT4ge1xuICAgIG9iamVjdEtleXMoY3VycmVudE9iamVjdCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgdmFsdWVBID0gbWVyZ2VkT2JqZWN0c1trZXldO1xuICAgICAgY29uc3QgdmFsdWVCID0gY3VycmVudE9iamVjdFtrZXldO1xuICAgICAgY29uc3QgYXJlT2JqZWN0cyA9IGlzT2JqZWN0KHZhbHVlQSkgJiYgaXNPYmplY3QodmFsdWVCKTtcbiAgICAgIG1lcmdlZE9iamVjdHNba2V5XSA9IGFyZU9iamVjdHMgPyBvYmplY3RzTWVyZ2VEZWVwKHZhbHVlQSwgdmFsdWVCKSA6IHZhbHVlQjtcbiAgICB9KTtcbiAgICByZXR1cm4gbWVyZ2VkT2JqZWN0cztcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gaXNNb3VzZUV2ZW50KGV2dCwgb3duZXJXaW5kb3cpIHtcbiAgcmV0dXJuIHR5cGVvZiBvd25lcldpbmRvdy5Nb3VzZUV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiBldnQgaW5zdGFuY2VvZiBvd25lcldpbmRvdy5Nb3VzZUV2ZW50O1xufVxuXG5mdW5jdGlvbiBBbGlnbm1lbnQoYWxpZ24sIHZpZXdTaXplKSB7XG4gIGNvbnN0IHByZWRlZmluZWQgPSB7XG4gICAgc3RhcnQsXG4gICAgY2VudGVyLFxuICAgIGVuZFxuICB9O1xuICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBmdW5jdGlvbiBjZW50ZXIobikge1xuICAgIHJldHVybiBlbmQobikgLyAyO1xuICB9XG4gIGZ1bmN0aW9uIGVuZChuKSB7XG4gICAgcmV0dXJuIHZpZXdTaXplIC0gbjtcbiAgfVxuICBmdW5jdGlvbiBtZWFzdXJlKG4sIGluZGV4KSB7XG4gICAgaWYgKGlzU3RyaW5nKGFsaWduKSkgcmV0dXJuIHByZWRlZmluZWRbYWxpZ25dKG4pO1xuICAgIHJldHVybiBhbGlnbih2aWV3U2l6ZSwgbiwgaW5kZXgpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgbWVhc3VyZVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gRXZlbnRTdG9yZSgpIHtcbiAgbGV0IGxpc3RlbmVycyA9IFtdO1xuICBmdW5jdGlvbiBhZGQobm9kZSwgdHlwZSwgaGFuZGxlciwgb3B0aW9ucyA9IHtcbiAgICBwYXNzaXZlOiB0cnVlXG4gIH0pIHtcbiAgICBsZXQgcmVtb3ZlTGlzdGVuZXI7XG4gICAgaWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiBub2RlKSB7XG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICByZW1vdmVMaXN0ZW5lciA9ICgpID0+IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGVnYWN5TWVkaWFRdWVyeUxpc3QgPSBub2RlO1xuICAgICAgbGVnYWN5TWVkaWFRdWVyeUxpc3QuYWRkTGlzdGVuZXIoaGFuZGxlcik7XG4gICAgICByZW1vdmVMaXN0ZW5lciA9ICgpID0+IGxlZ2FjeU1lZGlhUXVlcnlMaXN0LnJlbW92ZUxpc3RlbmVyKGhhbmRsZXIpO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMucHVzaChyZW1vdmVMaXN0ZW5lcik7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcihyZW1vdmUgPT4gcmVtb3ZlKCkpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgYWRkLFxuICAgIGNsZWFyXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBBbmltYXRpb25zKG93bmVyRG9jdW1lbnQsIG93bmVyV2luZG93LCB1cGRhdGUsIHJlbmRlcikge1xuICBjb25zdCBkb2N1bWVudFZpc2libGVIYW5kbGVyID0gRXZlbnRTdG9yZSgpO1xuICBjb25zdCB0aW1lU3RlcCA9IDEwMDAgLyA2MDtcbiAgbGV0IGxhc3RUaW1lU3RhbXAgPSBudWxsO1xuICBsZXQgbGFnID0gMDtcbiAgbGV0IGFuaW1hdGlvbkZyYW1lID0gMDtcbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBkb2N1bWVudFZpc2libGVIYW5kbGVyLmFkZChvd25lckRvY3VtZW50LCAndmlzaWJpbGl0eWNoYW5nZScsICgpID0+IHtcbiAgICAgIGlmIChvd25lckRvY3VtZW50LmhpZGRlbikgcmVzZXQoKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHN0b3AoKTtcbiAgICBkb2N1bWVudFZpc2libGVIYW5kbGVyLmNsZWFyKCk7XG4gIH1cbiAgZnVuY3Rpb24gYW5pbWF0ZSh0aW1lU3RhbXApIHtcbiAgICBpZiAoIWxhc3RUaW1lU3RhbXApIGxhc3RUaW1lU3RhbXAgPSB0aW1lU3RhbXA7XG4gICAgY29uc3QgZWxhcHNlZCA9IHRpbWVTdGFtcCAtIGxhc3RUaW1lU3RhbXA7XG4gICAgbGFzdFRpbWVTdGFtcCA9IHRpbWVTdGFtcDtcbiAgICBsYWcgKz0gZWxhcHNlZDtcbiAgICB3aGlsZSAobGFnID49IHRpbWVTdGVwKSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICAgIGxhZyAtPSB0aW1lU3RlcDtcbiAgICB9XG4gICAgY29uc3QgbGFnT2Zmc2V0ID0gbWF0aEFicyhsYWcgLyB0aW1lU3RlcCk7XG4gICAgcmVuZGVyKGxhZ09mZnNldCk7XG4gICAgaWYgKGFuaW1hdGlvbkZyYW1lKSBvd25lcldpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgaWYgKGFuaW1hdGlvbkZyYW1lKSByZXR1cm47XG4gICAgYW5pbWF0aW9uRnJhbWUgPSBvd25lcldpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBvd25lcldpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25GcmFtZSk7XG4gICAgbGFzdFRpbWVTdGFtcCA9IG51bGw7XG4gICAgbGFnID0gMDtcbiAgICBhbmltYXRpb25GcmFtZSA9IDA7XG4gIH1cbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgbGFzdFRpbWVTdGFtcCA9IG51bGw7XG4gICAgbGFnID0gMDtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXQsXG4gICAgZGVzdHJveSxcbiAgICBzdGFydCxcbiAgICBzdG9wLFxuICAgIHVwZGF0ZSxcbiAgICByZW5kZXJcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIEF4aXMoYXhpcywgZGlyZWN0aW9uKSB7XG4gIGNvbnN0IHNjcm9sbCA9IGF4aXMgPT09ICd5JyA/ICd5JyA6ICd4JztcbiAgY29uc3QgY3Jvc3MgPSBheGlzID09PSAneScgPyAneCcgOiAneSc7XG4gIGNvbnN0IHN0YXJ0RWRnZSA9IGdldFN0YXJ0RWRnZSgpO1xuICBjb25zdCBlbmRFZGdlID0gZ2V0RW5kRWRnZSgpO1xuICBmdW5jdGlvbiBtZWFzdXJlU2l6ZShub2RlUmVjdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IG5vZGVSZWN0O1xuICAgIHJldHVybiBzY3JvbGwgPT09ICd4JyA/IHdpZHRoIDogaGVpZ2h0O1xuICB9XG4gIGZ1bmN0aW9uIGdldFN0YXJ0RWRnZSgpIHtcbiAgICBpZiAoc2Nyb2xsID09PSAneScpIHJldHVybiAndG9wJztcbiAgICByZXR1cm4gZGlyZWN0aW9uID09PSAncnRsJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RW5kRWRnZSgpIHtcbiAgICBpZiAoc2Nyb2xsID09PSAneScpIHJldHVybiAnYm90dG9tJztcbiAgICByZXR1cm4gZGlyZWN0aW9uID09PSAncnRsJyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBzY3JvbGwsXG4gICAgY3Jvc3MsXG4gICAgc3RhcnRFZGdlLFxuICAgIGVuZEVkZ2UsXG4gICAgbWVhc3VyZVNpemVcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIExpbWl0KG1pbiA9IDAsIG1heCA9IDApIHtcbiAgY29uc3QgbGVuZ3RoID0gbWF0aEFicyhtaW4gLSBtYXgpO1xuICBmdW5jdGlvbiByZWFjaGVkTWluKG4pIHtcbiAgICByZXR1cm4gbiA8IG1pbjtcbiAgfVxuICBmdW5jdGlvbiByZWFjaGVkTWF4KG4pIHtcbiAgICByZXR1cm4gbiA+IG1heDtcbiAgfVxuICBmdW5jdGlvbiByZWFjaGVkQW55KG4pIHtcbiAgICByZXR1cm4gcmVhY2hlZE1pbihuKSB8fCByZWFjaGVkTWF4KG4pO1xuICB9XG4gIGZ1bmN0aW9uIGNvbnN0cmFpbihuKSB7XG4gICAgaWYgKCFyZWFjaGVkQW55KG4pKSByZXR1cm4gbjtcbiAgICByZXR1cm4gcmVhY2hlZE1pbihuKSA/IG1pbiA6IG1heDtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVPZmZzZXQobikge1xuICAgIGlmICghbGVuZ3RoKSByZXR1cm4gbjtcbiAgICByZXR1cm4gbiAtIGxlbmd0aCAqIE1hdGguY2VpbCgobiAtIG1heCkgLyBsZW5ndGgpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgbGVuZ3RoLFxuICAgIG1heCxcbiAgICBtaW4sXG4gICAgY29uc3RyYWluLFxuICAgIHJlYWNoZWRBbnksXG4gICAgcmVhY2hlZE1heCxcbiAgICByZWFjaGVkTWluLFxuICAgIHJlbW92ZU9mZnNldFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gQ291bnRlcihtYXgsIHN0YXJ0LCBsb29wKSB7XG4gIGNvbnN0IHtcbiAgICBjb25zdHJhaW5cbiAgfSA9IExpbWl0KDAsIG1heCk7XG4gIGNvbnN0IGxvb3BFbmQgPSBtYXggKyAxO1xuICBsZXQgY291bnRlciA9IHdpdGhpbkxpbWl0KHN0YXJ0KTtcbiAgZnVuY3Rpb24gd2l0aGluTGltaXQobikge1xuICAgIHJldHVybiAhbG9vcCA/IGNvbnN0cmFpbihuKSA6IG1hdGhBYnMoKGxvb3BFbmQgKyBuKSAlIGxvb3BFbmQpO1xuICB9XG4gIGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfVxuICBmdW5jdGlvbiBzZXQobikge1xuICAgIGNvdW50ZXIgPSB3aXRoaW5MaW1pdChuKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBmdW5jdGlvbiBhZGQobikge1xuICAgIHJldHVybiBjbG9uZSgpLnNldChnZXQoKSArIG4pO1xuICB9XG4gIGZ1bmN0aW9uIGNsb25lKCkge1xuICAgIHJldHVybiBDb3VudGVyKG1heCwgZ2V0KCksIGxvb3ApO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgZ2V0LFxuICAgIHNldCxcbiAgICBhZGQsXG4gICAgY2xvbmVcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIERpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgY29uc3Qgc2lnbiA9IGRpcmVjdGlvbiA9PT0gJ3J0bCcgPyAtMSA6IDE7XG4gIGZ1bmN0aW9uIGFwcGx5KG4pIHtcbiAgICByZXR1cm4gbiAqIHNpZ247XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBhcHBseVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gRHJhZ0hhbmRsZXIoYXhpcywgZGlyZWN0aW9uLCByb290Tm9kZSwgb3duZXJEb2N1bWVudCwgb3duZXJXaW5kb3csIHRhcmdldCwgZHJhZ1RyYWNrZXIsIGxvY2F0aW9uLCBhbmltYXRpb24sIHNjcm9sbFRvLCBzY3JvbGxCb2R5LCBzY3JvbGxUYXJnZXQsIGluZGV4LCBldmVudEhhbmRsZXIsIHBlcmNlbnRPZlZpZXcsIGRyYWdGcmVlLCBkcmFnVGhyZXNob2xkLCBza2lwU25hcHMsIGJhc2VGcmljdGlvbiwgd2F0Y2hEcmFnKSB7XG4gIGNvbnN0IHtcbiAgICBjcm9zczogY3Jvc3NBeGlzXG4gIH0gPSBheGlzO1xuICBjb25zdCBmb2N1c05vZGVzID0gWydJTlBVVCcsICdTRUxFQ1QnLCAnVEVYVEFSRUEnXTtcbiAgY29uc3Qgbm9uUGFzc2l2ZUV2ZW50ID0ge1xuICAgIHBhc3NpdmU6IGZhbHNlXG4gIH07XG4gIGNvbnN0IGluaXRFdmVudHMgPSBFdmVudFN0b3JlKCk7XG4gIGNvbnN0IGRyYWdFdmVudHMgPSBFdmVudFN0b3JlKCk7XG4gIGNvbnN0IGdvVG9OZXh0VGhyZXNob2xkID0gTGltaXQoNTAsIDIyNSkuY29uc3RyYWluKHBlcmNlbnRPZlZpZXcubWVhc3VyZSgyMCkpO1xuICBjb25zdCBzbmFwRm9yY2VCb29zdCA9IHtcbiAgICBtb3VzZTogMzAwLFxuICAgIHRvdWNoOiA0MDBcbiAgfTtcbiAgY29uc3QgZnJlZUZvcmNlQm9vc3QgPSB7XG4gICAgbW91c2U6IDUwMCxcbiAgICB0b3VjaDogNjAwXG4gIH07XG4gIGNvbnN0IGJhc2VTcGVlZCA9IGRyYWdGcmVlID8gNDMgOiAyNTtcbiAgbGV0IGlzTW92aW5nID0gZmFsc2U7XG4gIGxldCBzdGFydFNjcm9sbCA9IDA7XG4gIGxldCBzdGFydENyb3NzID0gMDtcbiAgbGV0IHBvaW50ZXJJc0Rvd24gPSBmYWxzZTtcbiAgbGV0IHByZXZlbnRTY3JvbGwgPSBmYWxzZTtcbiAgbGV0IHByZXZlbnRDbGljayA9IGZhbHNlO1xuICBsZXQgaXNNb3VzZSA9IGZhbHNlO1xuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpKSB7XG4gICAgaWYgKCF3YXRjaERyYWcpIHJldHVybjtcbiAgICBmdW5jdGlvbiBkb3duSWZBbGxvd2VkKGV2dCkge1xuICAgICAgaWYgKGlzQm9vbGVhbih3YXRjaERyYWcpIHx8IHdhdGNoRHJhZyhlbWJsYUFwaSwgZXZ0KSkgZG93bihldnQpO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gcm9vdE5vZGU7XG4gICAgaW5pdEV2ZW50cy5hZGQobm9kZSwgJ2RyYWdzdGFydCcsIGV2dCA9PiBldnQucHJldmVudERlZmF1bHQoKSwgbm9uUGFzc2l2ZUV2ZW50KS5hZGQobm9kZSwgJ3RvdWNobW92ZScsICgpID0+IHVuZGVmaW5lZCwgbm9uUGFzc2l2ZUV2ZW50KS5hZGQobm9kZSwgJ3RvdWNoZW5kJywgKCkgPT4gdW5kZWZpbmVkKS5hZGQobm9kZSwgJ3RvdWNoc3RhcnQnLCBkb3duSWZBbGxvd2VkKS5hZGQobm9kZSwgJ21vdXNlZG93bicsIGRvd25JZkFsbG93ZWQpLmFkZChub2RlLCAndG91Y2hjYW5jZWwnLCB1cCkuYWRkKG5vZGUsICdjb250ZXh0bWVudScsIHVwKS5hZGQobm9kZSwgJ2NsaWNrJywgY2xpY2ssIHRydWUpO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaW5pdEV2ZW50cy5jbGVhcigpO1xuICAgIGRyYWdFdmVudHMuY2xlYXIoKTtcbiAgfVxuICBmdW5jdGlvbiBhZGREcmFnRXZlbnRzKCkge1xuICAgIGNvbnN0IG5vZGUgPSBpc01vdXNlID8gb3duZXJEb2N1bWVudCA6IHJvb3ROb2RlO1xuICAgIGRyYWdFdmVudHMuYWRkKG5vZGUsICd0b3VjaG1vdmUnLCBtb3ZlLCBub25QYXNzaXZlRXZlbnQpLmFkZChub2RlLCAndG91Y2hlbmQnLCB1cCkuYWRkKG5vZGUsICdtb3VzZW1vdmUnLCBtb3ZlLCBub25QYXNzaXZlRXZlbnQpLmFkZChub2RlLCAnbW91c2V1cCcsIHVwKTtcbiAgfVxuICBmdW5jdGlvbiBpc0ZvY3VzTm9kZShub2RlKSB7XG4gICAgY29uc3Qgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lIHx8ICcnO1xuICAgIHJldHVybiBmb2N1c05vZGVzLmluY2x1ZGVzKG5vZGVOYW1lKTtcbiAgfVxuICBmdW5jdGlvbiBmb3JjZUJvb3N0KCkge1xuICAgIGNvbnN0IGJvb3N0ID0gZHJhZ0ZyZWUgPyBmcmVlRm9yY2VCb29zdCA6IHNuYXBGb3JjZUJvb3N0O1xuICAgIGNvbnN0IHR5cGUgPSBpc01vdXNlID8gJ21vdXNlJyA6ICd0b3VjaCc7XG4gICAgcmV0dXJuIGJvb3N0W3R5cGVdO1xuICB9XG4gIGZ1bmN0aW9uIGFsbG93ZWRGb3JjZShmb3JjZSwgdGFyZ2V0Q2hhbmdlZCkge1xuICAgIGNvbnN0IG5leHQgPSBpbmRleC5hZGQobWF0aFNpZ24oZm9yY2UpICogLTEpO1xuICAgIGNvbnN0IGJhc2VGb3JjZSA9IHNjcm9sbFRhcmdldC5ieURpc3RhbmNlKGZvcmNlLCAhZHJhZ0ZyZWUpLmRpc3RhbmNlO1xuICAgIGlmIChkcmFnRnJlZSB8fCBtYXRoQWJzKGZvcmNlKSA8IGdvVG9OZXh0VGhyZXNob2xkKSByZXR1cm4gYmFzZUZvcmNlO1xuICAgIGlmIChza2lwU25hcHMgJiYgdGFyZ2V0Q2hhbmdlZCkgcmV0dXJuIGJhc2VGb3JjZSAqIDAuNTtcbiAgICByZXR1cm4gc2Nyb2xsVGFyZ2V0LmJ5SW5kZXgobmV4dC5nZXQoKSwgMCkuZGlzdGFuY2U7XG4gIH1cbiAgZnVuY3Rpb24gZG93bihldnQpIHtcbiAgICBjb25zdCBpc01vdXNlRXZ0ID0gaXNNb3VzZUV2ZW50KGV2dCwgb3duZXJXaW5kb3cpO1xuICAgIGlzTW91c2UgPSBpc01vdXNlRXZ0O1xuICAgIGlmIChpc01vdXNlRXZ0ICYmIGV2dC5idXR0b24gIT09IDApIHJldHVybjtcbiAgICBpZiAoaXNGb2N1c05vZGUoZXZ0LnRhcmdldCkpIHJldHVybjtcbiAgICBwcmV2ZW50Q2xpY2sgPSBkcmFnRnJlZSAmJiBpc01vdXNlRXZ0ICYmICFldnQuYnV0dG9ucyAmJiBpc01vdmluZztcbiAgICBpc01vdmluZyA9IGRlbHRhQWJzKHRhcmdldC5nZXQoKSwgbG9jYXRpb24uZ2V0KCkpID49IDI7XG4gICAgcG9pbnRlcklzRG93biA9IHRydWU7XG4gICAgZHJhZ1RyYWNrZXIucG9pbnRlckRvd24oZXZ0KTtcbiAgICBzY3JvbGxCb2R5LnVzZUZyaWN0aW9uKDApLnVzZUR1cmF0aW9uKDApO1xuICAgIHRhcmdldC5zZXQobG9jYXRpb24pO1xuICAgIGFkZERyYWdFdmVudHMoKTtcbiAgICBzdGFydFNjcm9sbCA9IGRyYWdUcmFja2VyLnJlYWRQb2ludChldnQpO1xuICAgIHN0YXJ0Q3Jvc3MgPSBkcmFnVHJhY2tlci5yZWFkUG9pbnQoZXZ0LCBjcm9zc0F4aXMpO1xuICAgIGV2ZW50SGFuZGxlci5lbWl0KCdwb2ludGVyRG93bicpO1xuICB9XG4gIGZ1bmN0aW9uIG1vdmUoZXZ0KSB7XG4gICAgY29uc3QgbGFzdFNjcm9sbCA9IGRyYWdUcmFja2VyLnJlYWRQb2ludChldnQpO1xuICAgIGNvbnN0IGxhc3RDcm9zcyA9IGRyYWdUcmFja2VyLnJlYWRQb2ludChldnQsIGNyb3NzQXhpcyk7XG4gICAgY29uc3QgZGlmZlNjcm9sbCA9IGRlbHRhQWJzKGxhc3RTY3JvbGwsIHN0YXJ0U2Nyb2xsKTtcbiAgICBjb25zdCBkaWZmQ3Jvc3MgPSBkZWx0YUFicyhsYXN0Q3Jvc3MsIHN0YXJ0Q3Jvc3MpO1xuICAgIGlmICghcHJldmVudFNjcm9sbCAmJiAhaXNNb3VzZSkge1xuICAgICAgaWYgKCFldnQuY2FuY2VsYWJsZSkgcmV0dXJuIHVwKGV2dCk7XG4gICAgICBwcmV2ZW50U2Nyb2xsID0gZGlmZlNjcm9sbCA+IGRpZmZDcm9zcztcbiAgICAgIGlmICghcHJldmVudFNjcm9sbCkgcmV0dXJuIHVwKGV2dCk7XG4gICAgfVxuICAgIGNvbnN0IGRpZmYgPSBkcmFnVHJhY2tlci5wb2ludGVyTW92ZShldnQpO1xuICAgIGlmIChkaWZmU2Nyb2xsID4gZHJhZ1RocmVzaG9sZCkgcHJldmVudENsaWNrID0gdHJ1ZTtcbiAgICBzY3JvbGxCb2R5LnVzZUZyaWN0aW9uKDAuMykudXNlRHVyYXRpb24oMSk7XG4gICAgYW5pbWF0aW9uLnN0YXJ0KCk7XG4gICAgdGFyZ2V0LmFkZChkaXJlY3Rpb24uYXBwbHkoZGlmZikpO1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIGZ1bmN0aW9uIHVwKGV2dCkge1xuICAgIGNvbnN0IGN1cnJlbnRMb2NhdGlvbiA9IHNjcm9sbFRhcmdldC5ieURpc3RhbmNlKDAsIGZhbHNlKTtcbiAgICBjb25zdCB0YXJnZXRDaGFuZ2VkID0gY3VycmVudExvY2F0aW9uLmluZGV4ICE9PSBpbmRleC5nZXQoKTtcbiAgICBjb25zdCByYXdGb3JjZSA9IGRyYWdUcmFja2VyLnBvaW50ZXJVcChldnQpICogZm9yY2VCb29zdCgpO1xuICAgIGNvbnN0IGZvcmNlID0gYWxsb3dlZEZvcmNlKGRpcmVjdGlvbi5hcHBseShyYXdGb3JjZSksIHRhcmdldENoYW5nZWQpO1xuICAgIGNvbnN0IGZvcmNlRmFjdG9yID0gZmFjdG9yQWJzKHJhd0ZvcmNlLCBmb3JjZSk7XG4gICAgY29uc3Qgc3BlZWQgPSBiYXNlU3BlZWQgLSAxMCAqIGZvcmNlRmFjdG9yO1xuICAgIGNvbnN0IGZyaWN0aW9uID0gYmFzZUZyaWN0aW9uICsgZm9yY2VGYWN0b3IgLyA1MDtcbiAgICBwcmV2ZW50U2Nyb2xsID0gZmFsc2U7XG4gICAgcG9pbnRlcklzRG93biA9IGZhbHNlO1xuICAgIGRyYWdFdmVudHMuY2xlYXIoKTtcbiAgICBzY3JvbGxCb2R5LnVzZUR1cmF0aW9uKHNwZWVkKS51c2VGcmljdGlvbihmcmljdGlvbik7XG4gICAgc2Nyb2xsVG8uZGlzdGFuY2UoZm9yY2UsICFkcmFnRnJlZSk7XG4gICAgaXNNb3VzZSA9IGZhbHNlO1xuICAgIGV2ZW50SGFuZGxlci5lbWl0KCdwb2ludGVyVXAnKTtcbiAgfVxuICBmdW5jdGlvbiBjbGljayhldnQpIHtcbiAgICBpZiAocHJldmVudENsaWNrKSB7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlckRvd24oKSB7XG4gICAgcmV0dXJuIHBvaW50ZXJJc0Rvd247XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0LFxuICAgIHBvaW50ZXJEb3duLFxuICAgIGRlc3Ryb3lcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIERyYWdUcmFja2VyKGF4aXMsIG93bmVyV2luZG93KSB7XG4gIGNvbnN0IGxvZ0ludGVydmFsID0gMTcwO1xuICBsZXQgc3RhcnRFdmVudDtcbiAgbGV0IGxhc3RFdmVudDtcbiAgZnVuY3Rpb24gcmVhZFRpbWUoZXZ0KSB7XG4gICAgcmV0dXJuIGV2dC50aW1lU3RhbXA7XG4gIH1cbiAgZnVuY3Rpb24gcmVhZFBvaW50KGV2dCwgZXZ0QXhpcykge1xuICAgIGNvbnN0IHByb3BlcnR5ID0gZXZ0QXhpcyB8fCBheGlzLnNjcm9sbDtcbiAgICBjb25zdCBjb29yZCA9IGBjbGllbnQke3Byb3BlcnR5ID09PSAneCcgPyAnWCcgOiAnWSd9YDtcbiAgICByZXR1cm4gKGlzTW91c2VFdmVudChldnQsIG93bmVyV2luZG93KSA/IGV2dCA6IGV2dC50b3VjaGVzWzBdKVtjb29yZF07XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlckRvd24oZXZ0KSB7XG4gICAgc3RhcnRFdmVudCA9IGV2dDtcbiAgICBsYXN0RXZlbnQgPSBldnQ7XG4gICAgcmV0dXJuIHJlYWRQb2ludChldnQpO1xuICB9XG4gIGZ1bmN0aW9uIHBvaW50ZXJNb3ZlKGV2dCkge1xuICAgIGNvbnN0IGRpZmYgPSByZWFkUG9pbnQoZXZ0KSAtIHJlYWRQb2ludChsYXN0RXZlbnQpO1xuICAgIGNvbnN0IGV4cGlyZWQgPSByZWFkVGltZShldnQpIC0gcmVhZFRpbWUoc3RhcnRFdmVudCkgPiBsb2dJbnRlcnZhbDtcbiAgICBsYXN0RXZlbnQgPSBldnQ7XG4gICAgaWYgKGV4cGlyZWQpIHN0YXJ0RXZlbnQgPSBldnQ7XG4gICAgcmV0dXJuIGRpZmY7XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlclVwKGV2dCkge1xuICAgIGlmICghc3RhcnRFdmVudCB8fCAhbGFzdEV2ZW50KSByZXR1cm4gMDtcbiAgICBjb25zdCBkaWZmRHJhZyA9IHJlYWRQb2ludChsYXN0RXZlbnQpIC0gcmVhZFBvaW50KHN0YXJ0RXZlbnQpO1xuICAgIGNvbnN0IGRpZmZUaW1lID0gcmVhZFRpbWUoZXZ0KSAtIHJlYWRUaW1lKHN0YXJ0RXZlbnQpO1xuICAgIGNvbnN0IGV4cGlyZWQgPSByZWFkVGltZShldnQpIC0gcmVhZFRpbWUobGFzdEV2ZW50KSA+IGxvZ0ludGVydmFsO1xuICAgIGNvbnN0IGZvcmNlID0gZGlmZkRyYWcgLyBkaWZmVGltZTtcbiAgICBjb25zdCBpc0ZsaWNrID0gZGlmZlRpbWUgJiYgIWV4cGlyZWQgJiYgbWF0aEFicyhmb3JjZSkgPiAwLjE7XG4gICAgcmV0dXJuIGlzRmxpY2sgPyBmb3JjZSA6IDA7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBwb2ludGVyRG93bixcbiAgICBwb2ludGVyTW92ZSxcbiAgICBwb2ludGVyVXAsXG4gICAgcmVhZFBvaW50XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBOb2RlUmVjdHMoKSB7XG4gIGZ1bmN0aW9uIG1lYXN1cmUobm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9mZnNldFRvcCxcbiAgICAgIG9mZnNldExlZnQsXG4gICAgICBvZmZzZXRXaWR0aCxcbiAgICAgIG9mZnNldEhlaWdodFxuICAgIH0gPSBub2RlO1xuICAgIGNvbnN0IG9mZnNldCA9IHtcbiAgICAgIHRvcDogb2Zmc2V0VG9wLFxuICAgICAgcmlnaHQ6IG9mZnNldExlZnQgKyBvZmZzZXRXaWR0aCxcbiAgICAgIGJvdHRvbTogb2Zmc2V0VG9wICsgb2Zmc2V0SGVpZ2h0LFxuICAgICAgbGVmdDogb2Zmc2V0TGVmdCxcbiAgICAgIHdpZHRoOiBvZmZzZXRXaWR0aCxcbiAgICAgIGhlaWdodDogb2Zmc2V0SGVpZ2h0XG4gICAgfTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgbWVhc3VyZVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gUGVyY2VudE9mVmlldyh2aWV3U2l6ZSkge1xuICBmdW5jdGlvbiBtZWFzdXJlKG4pIHtcbiAgICByZXR1cm4gdmlld1NpemUgKiAobiAvIDEwMCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBtZWFzdXJlXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBSZXNpemVIYW5kbGVyKGNvbnRhaW5lciwgZXZlbnRIYW5kbGVyLCBvd25lcldpbmRvdywgc2xpZGVzLCBheGlzLCB3YXRjaFJlc2l6ZSwgbm9kZVJlY3RzKSB7XG4gIGxldCByZXNpemVPYnNlcnZlcjtcbiAgbGV0IGNvbnRhaW5lclNpemU7XG4gIGxldCBzbGlkZVNpemVzID0gW107XG4gIGxldCBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gcmVhZFNpemUobm9kZSkge1xuICAgIHJldHVybiBheGlzLm1lYXN1cmVTaXplKG5vZGVSZWN0cy5tZWFzdXJlKG5vZGUpKTtcbiAgfVxuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpKSB7XG4gICAgaWYgKCF3YXRjaFJlc2l6ZSkgcmV0dXJuO1xuICAgIGNvbnRhaW5lclNpemUgPSByZWFkU2l6ZShjb250YWluZXIpO1xuICAgIHNsaWRlU2l6ZXMgPSBzbGlkZXMubWFwKHJlYWRTaXplKTtcbiAgICBmdW5jdGlvbiBkZWZhdWx0Q2FsbGJhY2soZW50cmllcykge1xuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIGNvbnN0IGlzQ29udGFpbmVyID0gZW50cnkudGFyZ2V0ID09PSBjb250YWluZXI7XG4gICAgICAgIGNvbnN0IHNsaWRlSW5kZXggPSBzbGlkZXMuaW5kZXhPZihlbnRyeS50YXJnZXQpO1xuICAgICAgICBjb25zdCBsYXN0U2l6ZSA9IGlzQ29udGFpbmVyID8gY29udGFpbmVyU2l6ZSA6IHNsaWRlU2l6ZXNbc2xpZGVJbmRleF07XG4gICAgICAgIGNvbnN0IG5ld1NpemUgPSByZWFkU2l6ZShpc0NvbnRhaW5lciA/IGNvbnRhaW5lciA6IHNsaWRlc1tzbGlkZUluZGV4XSk7XG4gICAgICAgIGNvbnN0IGRpZmZTaXplID0gbWF0aEFicyhuZXdTaXplIC0gbGFzdFNpemUpO1xuICAgICAgICBpZiAoZGlmZlNpemUgPj0gMC41KSB7XG4gICAgICAgICAgb3duZXJXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGVtYmxhQXBpLnJlSW5pdCgpO1xuICAgICAgICAgICAgZXZlbnRIYW5kbGVyLmVtaXQoJ3Jlc2l6ZScpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgaWYgKGlzQm9vbGVhbih3YXRjaFJlc2l6ZSkgfHwgd2F0Y2hSZXNpemUoZW1ibGFBcGksIGVudHJpZXMpKSB7XG4gICAgICAgIGRlZmF1bHRDYWxsYmFjayhlbnRyaWVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBvYnNlcnZlTm9kZXMgPSBbY29udGFpbmVyXS5jb25jYXQoc2xpZGVzKTtcbiAgICBvYnNlcnZlTm9kZXMuZm9yRWFjaChub2RlID0+IHJlc2l6ZU9ic2VydmVyLm9ic2VydmUobm9kZSkpO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKHJlc2l6ZU9ic2VydmVyKSByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXQsXG4gICAgZGVzdHJveVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsQm9keShsb2NhdGlvbiwgb2Zmc2V0TG9jYXRpb24sIHRhcmdldCwgYmFzZUR1cmF0aW9uLCBiYXNlRnJpY3Rpb24pIHtcbiAgbGV0IGJvZHlWZWxvY2l0eSA9IDA7XG4gIGxldCBzY3JvbGxEaXJlY3Rpb24gPSAwO1xuICBsZXQgc2Nyb2xsRHVyYXRpb24gPSBiYXNlRHVyYXRpb247XG4gIGxldCBzY3JvbGxGcmljdGlvbiA9IGJhc2VGcmljdGlvbjtcbiAgbGV0IHJhd0xvY2F0aW9uID0gbG9jYXRpb24uZ2V0KCk7XG4gIGxldCByYXdMb2NhdGlvblByZXZpb3VzID0gMDtcbiAgZnVuY3Rpb24gc2VlaygpIHtcbiAgICBjb25zdCBkaWZmID0gdGFyZ2V0LmdldCgpIC0gbG9jYXRpb24uZ2V0KCk7XG4gICAgY29uc3QgaXNJbnN0YW50ID0gIXNjcm9sbER1cmF0aW9uO1xuICAgIGxldCBkaXJlY3Rpb25EaWZmID0gMDtcbiAgICBpZiAoaXNJbnN0YW50KSB7XG4gICAgICBib2R5VmVsb2NpdHkgPSAwO1xuICAgICAgbG9jYXRpb24uc2V0KHRhcmdldCk7XG4gICAgICBkaXJlY3Rpb25EaWZmID0gZGlmZjtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9keVZlbG9jaXR5ICs9IGRpZmYgLyBzY3JvbGxEdXJhdGlvbjtcbiAgICAgIGJvZHlWZWxvY2l0eSAqPSBzY3JvbGxGcmljdGlvbjtcbiAgICAgIHJhd0xvY2F0aW9uICs9IGJvZHlWZWxvY2l0eTtcbiAgICAgIGxvY2F0aW9uLmFkZChib2R5VmVsb2NpdHkpO1xuICAgICAgZGlyZWN0aW9uRGlmZiA9IHJhd0xvY2F0aW9uIC0gcmF3TG9jYXRpb25QcmV2aW91cztcbiAgICB9XG4gICAgc2Nyb2xsRGlyZWN0aW9uID0gbWF0aFNpZ24oZGlyZWN0aW9uRGlmZik7XG4gICAgcmF3TG9jYXRpb25QcmV2aW91cyA9IHJhd0xvY2F0aW9uO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIHNldHRsZWQoKSB7XG4gICAgY29uc3QgZGlmZiA9IHRhcmdldC5nZXQoKSAtIG9mZnNldExvY2F0aW9uLmdldCgpO1xuICAgIHJldHVybiBtYXRoQWJzKGRpZmYpIDwgMC4wMDE7XG4gIH1cbiAgZnVuY3Rpb24gZHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHNjcm9sbER1cmF0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIGRpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gc2Nyb2xsRGlyZWN0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIHZlbG9jaXR5KCkge1xuICAgIHJldHVybiBib2R5VmVsb2NpdHk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlQmFzZUR1cmF0aW9uKCkge1xuICAgIHJldHVybiB1c2VEdXJhdGlvbihiYXNlRHVyYXRpb24pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUJhc2VGcmljdGlvbigpIHtcbiAgICByZXR1cm4gdXNlRnJpY3Rpb24oYmFzZUZyaWN0aW9uKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VEdXJhdGlvbihuKSB7XG4gICAgc2Nyb2xsRHVyYXRpb24gPSBuO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUZyaWN0aW9uKG4pIHtcbiAgICBzY3JvbGxGcmljdGlvbiA9IG47XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBkaXJlY3Rpb24sXG4gICAgZHVyYXRpb24sXG4gICAgdmVsb2NpdHksXG4gICAgc2VlayxcbiAgICBzZXR0bGVkLFxuICAgIHVzZUJhc2VGcmljdGlvbixcbiAgICB1c2VCYXNlRHVyYXRpb24sXG4gICAgdXNlRnJpY3Rpb24sXG4gICAgdXNlRHVyYXRpb25cbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNjcm9sbEJvdW5kcyhsaW1pdCwgbG9jYXRpb24sIHRhcmdldCwgc2Nyb2xsQm9keSwgcGVyY2VudE9mVmlldykge1xuICBjb25zdCBwdWxsQmFja1RocmVzaG9sZCA9IHBlcmNlbnRPZlZpZXcubWVhc3VyZSgxMCk7XG4gIGNvbnN0IGVkZ2VPZmZzZXRUb2xlcmFuY2UgPSBwZXJjZW50T2ZWaWV3Lm1lYXN1cmUoNTApO1xuICBjb25zdCBmcmljdGlvbkxpbWl0ID0gTGltaXQoMC4xLCAwLjk5KTtcbiAgbGV0IGRpc2FibGVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIHNob3VsZENvbnN0cmFpbigpIHtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWxpbWl0LnJlYWNoZWRBbnkodGFyZ2V0LmdldCgpKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghbGltaXQucmVhY2hlZEFueShsb2NhdGlvbi5nZXQoKSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBjb25zdHJhaW4ocG9pbnRlckRvd24pIHtcbiAgICBpZiAoIXNob3VsZENvbnN0cmFpbigpKSByZXR1cm47XG4gICAgY29uc3QgZWRnZSA9IGxpbWl0LnJlYWNoZWRNaW4obG9jYXRpb24uZ2V0KCkpID8gJ21pbicgOiAnbWF4JztcbiAgICBjb25zdCBkaWZmVG9FZGdlID0gbWF0aEFicyhsaW1pdFtlZGdlXSAtIGxvY2F0aW9uLmdldCgpKTtcbiAgICBjb25zdCBkaWZmVG9UYXJnZXQgPSB0YXJnZXQuZ2V0KCkgLSBsb2NhdGlvbi5nZXQoKTtcbiAgICBjb25zdCBmcmljdGlvbiA9IGZyaWN0aW9uTGltaXQuY29uc3RyYWluKGRpZmZUb0VkZ2UgLyBlZGdlT2Zmc2V0VG9sZXJhbmNlKTtcbiAgICB0YXJnZXQuc3VidHJhY3QoZGlmZlRvVGFyZ2V0ICogZnJpY3Rpb24pO1xuICAgIGlmICghcG9pbnRlckRvd24gJiYgbWF0aEFicyhkaWZmVG9UYXJnZXQpIDwgcHVsbEJhY2tUaHJlc2hvbGQpIHtcbiAgICAgIHRhcmdldC5zZXQobGltaXQuY29uc3RyYWluKHRhcmdldC5nZXQoKSkpO1xuICAgICAgc2Nyb2xsQm9keS51c2VEdXJhdGlvbigyNSkudXNlQmFzZUZyaWN0aW9uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRvZ2dsZUFjdGl2ZShhY3RpdmUpIHtcbiAgICBkaXNhYmxlZCA9ICFhY3RpdmU7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBjb25zdHJhaW4sXG4gICAgdG9nZ2xlQWN0aXZlXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxDb250YWluKHZpZXdTaXplLCBjb250ZW50U2l6ZSwgc25hcHNBbGlnbmVkLCBjb250YWluU2Nyb2xsLCBwaXhlbFRvbGVyYW5jZSkge1xuICBjb25zdCBzY3JvbGxCb3VuZHMgPSBMaW1pdCgtY29udGVudFNpemUgKyB2aWV3U2l6ZSwgMCk7XG4gIGNvbnN0IHNuYXBzQm91bmRlZCA9IG1lYXN1cmVCb3VuZGVkKCk7XG4gIGNvbnN0IHNjcm9sbENvbnRhaW5MaW1pdCA9IGZpbmRTY3JvbGxDb250YWluTGltaXQoKTtcbiAgY29uc3Qgc25hcHNDb250YWluZWQgPSBtZWFzdXJlQ29udGFpbmVkKCk7XG4gIGZ1bmN0aW9uIGZpbmRTY3JvbGxDb250YWluTGltaXQoKSB7XG4gICAgY29uc3Qgc3RhcnRTbmFwID0gc25hcHNCb3VuZGVkWzBdO1xuICAgIGNvbnN0IGVuZFNuYXAgPSBhcnJheUxhc3Qoc25hcHNCb3VuZGVkKTtcbiAgICBjb25zdCBtaW4gPSBzbmFwc0JvdW5kZWQubGFzdEluZGV4T2Yoc3RhcnRTbmFwKTtcbiAgICBjb25zdCBtYXggPSBzbmFwc0JvdW5kZWQuaW5kZXhPZihlbmRTbmFwKSArIDE7XG4gICAgcmV0dXJuIExpbWl0KG1pbiwgbWF4KTtcbiAgfVxuICBmdW5jdGlvbiBtZWFzdXJlQm91bmRlZCgpIHtcbiAgICByZXR1cm4gc25hcHNBbGlnbmVkLm1hcCgoc25hcEFsaWduZWQsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBpc0ZpcnN0ID0gIWluZGV4O1xuICAgICAgY29uc3QgaXNMYXN0ID0gYXJyYXlJc0xhc3RJbmRleChzbmFwc0FsaWduZWQsIGluZGV4KTtcbiAgICAgIGlmIChpc0ZpcnN0KSByZXR1cm4gc2Nyb2xsQm91bmRzLm1heDtcbiAgICAgIGlmIChpc0xhc3QpIHJldHVybiBzY3JvbGxCb3VuZHMubWluO1xuICAgICAgcmV0dXJuIHNjcm9sbEJvdW5kcy5jb25zdHJhaW4oc25hcEFsaWduZWQpO1xuICAgIH0pLm1hcChzY3JvbGxCb3VuZCA9PiBwYXJzZUZsb2F0KHNjcm9sbEJvdW5kLnRvRml4ZWQoMykpKTtcbiAgfVxuICBmdW5jdGlvbiBtZWFzdXJlQ29udGFpbmVkKCkge1xuICAgIGlmIChjb250ZW50U2l6ZSA8PSB2aWV3U2l6ZSArIHBpeGVsVG9sZXJhbmNlKSByZXR1cm4gW3Njcm9sbEJvdW5kcy5tYXhdO1xuICAgIGlmIChjb250YWluU2Nyb2xsID09PSAna2VlcFNuYXBzJykgcmV0dXJuIHNuYXBzQm91bmRlZDtcbiAgICBjb25zdCB7XG4gICAgICBtaW4sXG4gICAgICBtYXhcbiAgICB9ID0gc2Nyb2xsQ29udGFpbkxpbWl0O1xuICAgIHJldHVybiBzbmFwc0JvdW5kZWQuc2xpY2UobWluLCBtYXgpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgc25hcHNDb250YWluZWQsXG4gICAgc2Nyb2xsQ29udGFpbkxpbWl0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxMaW1pdChjb250ZW50U2l6ZSwgc2Nyb2xsU25hcHMsIGxvb3ApIHtcbiAgY29uc3QgbWF4ID0gc2Nyb2xsU25hcHNbMF07XG4gIGNvbnN0IG1pbiA9IGxvb3AgPyBtYXggLSBjb250ZW50U2l6ZSA6IGFycmF5TGFzdChzY3JvbGxTbmFwcyk7XG4gIGNvbnN0IGxpbWl0ID0gTGltaXQobWluLCBtYXgpO1xuICBjb25zdCBzZWxmID0ge1xuICAgIGxpbWl0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxMb29wZXIoY29udGVudFNpemUsIGxpbWl0LCBvZmZzZXRMb2NhdGlvbiwgdmVjdG9ycykge1xuICBjb25zdCBqb2ludFNhZmV0eSA9IDAuMTtcbiAgY29uc3QgbWluID0gbGltaXQubWluICsgam9pbnRTYWZldHk7XG4gIGNvbnN0IG1heCA9IGxpbWl0Lm1heCArIGpvaW50U2FmZXR5O1xuICBjb25zdCB7XG4gICAgcmVhY2hlZE1pbixcbiAgICByZWFjaGVkTWF4XG4gIH0gPSBMaW1pdChtaW4sIG1heCk7XG4gIGZ1bmN0aW9uIHNob3VsZExvb3AoZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gMSkgcmV0dXJuIHJlYWNoZWRNYXgob2Zmc2V0TG9jYXRpb24uZ2V0KCkpO1xuICAgIGlmIChkaXJlY3Rpb24gPT09IC0xKSByZXR1cm4gcmVhY2hlZE1pbihvZmZzZXRMb2NhdGlvbi5nZXQoKSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIGxvb3AoZGlyZWN0aW9uKSB7XG4gICAgaWYgKCFzaG91bGRMb29wKGRpcmVjdGlvbikpIHJldHVybjtcbiAgICBjb25zdCBsb29wRGlzdGFuY2UgPSBjb250ZW50U2l6ZSAqIChkaXJlY3Rpb24gKiAtMSk7XG4gICAgdmVjdG9ycy5mb3JFYWNoKHYgPT4gdi5hZGQobG9vcERpc3RhbmNlKSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBsb29wXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxQcm9ncmVzcyhsaW1pdCkge1xuICBjb25zdCB7XG4gICAgbWF4LFxuICAgIGxlbmd0aFxuICB9ID0gbGltaXQ7XG4gIGZ1bmN0aW9uIGdldChuKSB7XG4gICAgY29uc3QgY3VycmVudExvY2F0aW9uID0gbiAtIG1heDtcbiAgICByZXR1cm4gbGVuZ3RoID8gY3VycmVudExvY2F0aW9uIC8gLWxlbmd0aCA6IDA7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBnZXRcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNjcm9sbFNuYXBzKGF4aXMsIGFsaWdubWVudCwgY29udGFpbmVyUmVjdCwgc2xpZGVSZWN0cywgc2xpZGVzVG9TY3JvbGwpIHtcbiAgY29uc3Qge1xuICAgIHN0YXJ0RWRnZSxcbiAgICBlbmRFZGdlXG4gIH0gPSBheGlzO1xuICBjb25zdCB7XG4gICAgZ3JvdXBTbGlkZXNcbiAgfSA9IHNsaWRlc1RvU2Nyb2xsO1xuICBjb25zdCBhbGlnbm1lbnRzID0gbWVhc3VyZVNpemVzKCkubWFwKGFsaWdubWVudC5tZWFzdXJlKTtcbiAgY29uc3Qgc25hcHMgPSBtZWFzdXJlVW5hbGlnbmVkKCk7XG4gIGNvbnN0IHNuYXBzQWxpZ25lZCA9IG1lYXN1cmVBbGlnbmVkKCk7XG4gIGZ1bmN0aW9uIG1lYXN1cmVTaXplcygpIHtcbiAgICByZXR1cm4gZ3JvdXBTbGlkZXMoc2xpZGVSZWN0cykubWFwKHJlY3RzID0+IGFycmF5TGFzdChyZWN0cylbZW5kRWRnZV0gLSByZWN0c1swXVtzdGFydEVkZ2VdKS5tYXAobWF0aEFicyk7XG4gIH1cbiAgZnVuY3Rpb24gbWVhc3VyZVVuYWxpZ25lZCgpIHtcbiAgICByZXR1cm4gc2xpZGVSZWN0cy5tYXAocmVjdCA9PiBjb250YWluZXJSZWN0W3N0YXJ0RWRnZV0gLSByZWN0W3N0YXJ0RWRnZV0pLm1hcChzbmFwID0+IC1tYXRoQWJzKHNuYXApKTtcbiAgfVxuICBmdW5jdGlvbiBtZWFzdXJlQWxpZ25lZCgpIHtcbiAgICByZXR1cm4gZ3JvdXBTbGlkZXMoc25hcHMpLm1hcChnID0+IGdbMF0pLm1hcCgoc25hcCwgaW5kZXgpID0+IHNuYXAgKyBhbGlnbm1lbnRzW2luZGV4XSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBzbmFwcyxcbiAgICBzbmFwc0FsaWduZWRcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNsaWRlUmVnaXN0cnkoY29udGFpblNuYXBzLCBjb250YWluU2Nyb2xsLCBzY3JvbGxTbmFwcywgc2Nyb2xsQ29udGFpbkxpbWl0LCBzbGlkZXNUb1Njcm9sbCwgc2xpZGVJbmRleGVzKSB7XG4gIGNvbnN0IHtcbiAgICBncm91cFNsaWRlc1xuICB9ID0gc2xpZGVzVG9TY3JvbGw7XG4gIGNvbnN0IHtcbiAgICBtaW4sXG4gICAgbWF4XG4gIH0gPSBzY3JvbGxDb250YWluTGltaXQ7XG4gIGNvbnN0IHNsaWRlUmVnaXN0cnkgPSBjcmVhdGVTbGlkZVJlZ2lzdHJ5KCk7XG4gIGZ1bmN0aW9uIGNyZWF0ZVNsaWRlUmVnaXN0cnkoKSB7XG4gICAgY29uc3QgZ3JvdXBlZFNsaWRlSW5kZXhlcyA9IGdyb3VwU2xpZGVzKHNsaWRlSW5kZXhlcyk7XG4gICAgY29uc3QgZG9Ob3RDb250YWluID0gIWNvbnRhaW5TbmFwcyB8fCBjb250YWluU2Nyb2xsID09PSAna2VlcFNuYXBzJztcbiAgICBpZiAoc2Nyb2xsU25hcHMubGVuZ3RoID09PSAxKSByZXR1cm4gW3NsaWRlSW5kZXhlc107XG4gICAgaWYgKGRvTm90Q29udGFpbikgcmV0dXJuIGdyb3VwZWRTbGlkZUluZGV4ZXM7XG4gICAgcmV0dXJuIGdyb3VwZWRTbGlkZUluZGV4ZXMuc2xpY2UobWluLCBtYXgpLm1hcCgoZ3JvdXAsIGluZGV4LCBncm91cHMpID0+IHtcbiAgICAgIGNvbnN0IGlzRmlyc3QgPSAhaW5kZXg7XG4gICAgICBjb25zdCBpc0xhc3QgPSBhcnJheUlzTGFzdEluZGV4KGdyb3VwcywgaW5kZXgpO1xuICAgICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBhcnJheUxhc3QoZ3JvdXBzWzBdKSArIDE7XG4gICAgICAgIHJldHVybiBhcnJheUZyb21OdW1iZXIocmFuZ2UpO1xuICAgICAgfVxuICAgICAgaWYgKGlzTGFzdCkge1xuICAgICAgICBjb25zdCByYW5nZSA9IGFycmF5TGFzdEluZGV4KHNsaWRlSW5kZXhlcykgLSBhcnJheUxhc3QoZ3JvdXBzKVswXSArIDE7XG4gICAgICAgIHJldHVybiBhcnJheUZyb21OdW1iZXIocmFuZ2UsIGFycmF5TGFzdChncm91cHMpWzBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIHNsaWRlUmVnaXN0cnlcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNjcm9sbFRhcmdldChsb29wLCBzY3JvbGxTbmFwcywgY29udGVudFNpemUsIGxpbWl0LCB0YXJnZXRWZWN0b3IpIHtcbiAgY29uc3Qge1xuICAgIHJlYWNoZWRBbnksXG4gICAgcmVtb3ZlT2Zmc2V0LFxuICAgIGNvbnN0cmFpblxuICB9ID0gbGltaXQ7XG4gIGZ1bmN0aW9uIG1pbkRpc3RhbmNlKGRpc3RhbmNlcykge1xuICAgIHJldHVybiBkaXN0YW5jZXMuY29uY2F0KCkuc29ydCgoYSwgYikgPT4gbWF0aEFicyhhKSAtIG1hdGhBYnMoYikpWzBdO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmRUYXJnZXRTbmFwKHRhcmdldCkge1xuICAgIGNvbnN0IGRpc3RhbmNlID0gbG9vcCA/IHJlbW92ZU9mZnNldCh0YXJnZXQpIDogY29uc3RyYWluKHRhcmdldCk7XG4gICAgY29uc3QgYXNjRGlmZnNUb1NuYXBzID0gc2Nyb2xsU25hcHMubWFwKHNjcm9sbFNuYXAgPT4gc2Nyb2xsU25hcCAtIGRpc3RhbmNlKS5tYXAoZGlmZlRvU25hcCA9PiBzaG9ydGN1dChkaWZmVG9TbmFwLCAwKSkubWFwKChkaWZmLCBpKSA9PiAoe1xuICAgICAgZGlmZixcbiAgICAgIGluZGV4OiBpXG4gICAgfSkpLnNvcnQoKGQxLCBkMikgPT4gbWF0aEFicyhkMS5kaWZmKSAtIG1hdGhBYnMoZDIuZGlmZikpO1xuICAgIGNvbnN0IHtcbiAgICAgIGluZGV4XG4gICAgfSA9IGFzY0RpZmZzVG9TbmFwc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5kZXgsXG4gICAgICBkaXN0YW5jZVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gc2hvcnRjdXQodGFyZ2V0LCBkaXJlY3Rpb24pIHtcbiAgICBjb25zdCB0YXJnZXRzID0gW3RhcmdldCwgdGFyZ2V0ICsgY29udGVudFNpemUsIHRhcmdldCAtIGNvbnRlbnRTaXplXTtcbiAgICBpZiAoIWxvb3ApIHJldHVybiB0YXJnZXRzWzBdO1xuICAgIGlmICghZGlyZWN0aW9uKSByZXR1cm4gbWluRGlzdGFuY2UodGFyZ2V0cyk7XG4gICAgY29uc3QgbWF0Y2hpbmdUYXJnZXRzID0gdGFyZ2V0cy5maWx0ZXIodCA9PiBtYXRoU2lnbih0KSA9PT0gZGlyZWN0aW9uKTtcbiAgICBpZiAobWF0Y2hpbmdUYXJnZXRzLmxlbmd0aCkgcmV0dXJuIG1pbkRpc3RhbmNlKG1hdGNoaW5nVGFyZ2V0cyk7XG4gICAgcmV0dXJuIGFycmF5TGFzdCh0YXJnZXRzKSAtIGNvbnRlbnRTaXplO1xuICB9XG4gIGZ1bmN0aW9uIGJ5SW5kZXgoaW5kZXgsIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IGRpZmZUb1NuYXAgPSBzY3JvbGxTbmFwc1tpbmRleF0gLSB0YXJnZXRWZWN0b3IuZ2V0KCk7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBzaG9ydGN1dChkaWZmVG9TbmFwLCBkaXJlY3Rpb24pO1xuICAgIHJldHVybiB7XG4gICAgICBpbmRleCxcbiAgICAgIGRpc3RhbmNlXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBieURpc3RhbmNlKGRpc3RhbmNlLCBzbmFwKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0VmVjdG9yLmdldCgpICsgZGlzdGFuY2U7XG4gICAgY29uc3Qge1xuICAgICAgaW5kZXgsXG4gICAgICBkaXN0YW5jZTogdGFyZ2V0U25hcERpc3RhbmNlXG4gICAgfSA9IGZpbmRUYXJnZXRTbmFwKHRhcmdldCk7XG4gICAgY29uc3QgcmVhY2hlZEJvdW5kID0gIWxvb3AgJiYgcmVhY2hlZEFueSh0YXJnZXQpO1xuICAgIGlmICghc25hcCB8fCByZWFjaGVkQm91bmQpIHJldHVybiB7XG4gICAgICBpbmRleCxcbiAgICAgIGRpc3RhbmNlXG4gICAgfTtcbiAgICBjb25zdCBkaWZmVG9TbmFwID0gc2Nyb2xsU25hcHNbaW5kZXhdIC0gdGFyZ2V0U25hcERpc3RhbmNlO1xuICAgIGNvbnN0IHNuYXBEaXN0YW5jZSA9IGRpc3RhbmNlICsgc2hvcnRjdXQoZGlmZlRvU25hcCwgMCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluZGV4LFxuICAgICAgZGlzdGFuY2U6IHNuYXBEaXN0YW5jZVxuICAgIH07XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBieURpc3RhbmNlLFxuICAgIGJ5SW5kZXgsXG4gICAgc2hvcnRjdXRcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNjcm9sbFRvKGFuaW1hdGlvbiwgaW5kZXhDdXJyZW50LCBpbmRleFByZXZpb3VzLCBzY3JvbGxCb2R5LCBzY3JvbGxUYXJnZXQsIHRhcmdldFZlY3RvciwgZXZlbnRIYW5kbGVyKSB7XG4gIGZ1bmN0aW9uIHNjcm9sbFRvKHRhcmdldCkge1xuICAgIGNvbnN0IGRpc3RhbmNlRGlmZiA9IHRhcmdldC5kaXN0YW5jZTtcbiAgICBjb25zdCBpbmRleERpZmYgPSB0YXJnZXQuaW5kZXggIT09IGluZGV4Q3VycmVudC5nZXQoKTtcbiAgICB0YXJnZXRWZWN0b3IuYWRkKGRpc3RhbmNlRGlmZik7XG4gICAgaWYgKGRpc3RhbmNlRGlmZikge1xuICAgICAgaWYgKHNjcm9sbEJvZHkuZHVyYXRpb24oKSkge1xuICAgICAgICBhbmltYXRpb24uc3RhcnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuaW1hdGlvbi51cGRhdGUoKTtcbiAgICAgICAgYW5pbWF0aW9uLnJlbmRlcigxKTtcbiAgICAgICAgYW5pbWF0aW9uLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5kZXhEaWZmKSB7XG4gICAgICBpbmRleFByZXZpb3VzLnNldChpbmRleEN1cnJlbnQuZ2V0KCkpO1xuICAgICAgaW5kZXhDdXJyZW50LnNldCh0YXJnZXQuaW5kZXgpO1xuICAgICAgZXZlbnRIYW5kbGVyLmVtaXQoJ3NlbGVjdCcpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkaXN0YW5jZShuLCBzbmFwKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gc2Nyb2xsVGFyZ2V0LmJ5RGlzdGFuY2Uobiwgc25hcCk7XG4gICAgc2Nyb2xsVG8odGFyZ2V0KTtcbiAgfVxuICBmdW5jdGlvbiBpbmRleChuLCBkaXJlY3Rpb24pIHtcbiAgICBjb25zdCB0YXJnZXRJbmRleCA9IGluZGV4Q3VycmVudC5jbG9uZSgpLnNldChuKTtcbiAgICBjb25zdCB0YXJnZXQgPSBzY3JvbGxUYXJnZXQuYnlJbmRleCh0YXJnZXRJbmRleC5nZXQoKSwgZGlyZWN0aW9uKTtcbiAgICBzY3JvbGxUbyh0YXJnZXQpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgZGlzdGFuY2UsXG4gICAgaW5kZXhcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNsaWRlRm9jdXMocm9vdCwgc2xpZGVzLCBzbGlkZVJlZ2lzdHJ5LCBzY3JvbGxUbywgc2Nyb2xsQm9keSwgZXZlbnRTdG9yZSkge1xuICBsZXQgbGFzdFRhYlByZXNzVGltZSA9IDA7XG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgZXZlbnRTdG9yZS5hZGQoZG9jdW1lbnQsICdrZXlkb3duJywgcmVnaXN0ZXJUYWJQcmVzcywgZmFsc2UpO1xuICAgIHNsaWRlcy5mb3JFYWNoKGFkZFNsaWRlRm9jdXNFdmVudCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVnaXN0ZXJUYWJQcmVzcyhldmVudCkge1xuICAgIGlmIChldmVudC5jb2RlID09PSAnVGFiJykgbGFzdFRhYlByZXNzVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZFNsaWRlRm9jdXNFdmVudChzbGlkZSkge1xuICAgIGNvbnN0IGZvY3VzID0gKCkgPT4ge1xuICAgICAgY29uc3Qgbm93VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgY29uc3QgZGlmZlRpbWUgPSBub3dUaW1lIC0gbGFzdFRhYlByZXNzVGltZTtcbiAgICAgIGlmIChkaWZmVGltZSA+IDEwKSByZXR1cm47XG4gICAgICByb290LnNjcm9sbExlZnQgPSAwO1xuICAgICAgY29uc3QgaW5kZXggPSBzbGlkZXMuaW5kZXhPZihzbGlkZSk7XG4gICAgICBjb25zdCBncm91cCA9IHNsaWRlUmVnaXN0cnkuZmluZEluZGV4KGdyb3VwID0+IGdyb3VwLmluY2x1ZGVzKGluZGV4KSk7XG4gICAgICBpZiAoIWlzTnVtYmVyKGdyb3VwKSkgcmV0dXJuO1xuICAgICAgc2Nyb2xsQm9keS51c2VEdXJhdGlvbigwKTtcbiAgICAgIHNjcm9sbFRvLmluZGV4KGdyb3VwLCAwKTtcbiAgICB9O1xuICAgIGV2ZW50U3RvcmUuYWRkKHNsaWRlLCAnZm9jdXMnLCBmb2N1cywge1xuICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9KTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXRcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFZlY3RvcjFEKGluaXRpYWxWYWx1ZSkge1xuICBsZXQgdmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gc2V0KG4pIHtcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZUlucHV0KG4pO1xuICB9XG4gIGZ1bmN0aW9uIGFkZChuKSB7XG4gICAgdmFsdWUgKz0gbm9ybWFsaXplSW5wdXQobik7XG4gIH1cbiAgZnVuY3Rpb24gc3VidHJhY3Qobikge1xuICAgIHZhbHVlIC09IG5vcm1hbGl6ZUlucHV0KG4pO1xuICB9XG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUlucHV0KG4pIHtcbiAgICByZXR1cm4gaXNOdW1iZXIobikgPyBuIDogbi5nZXQoKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGdldCxcbiAgICBzZXQsXG4gICAgYWRkLFxuICAgIHN1YnRyYWN0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBUcmFuc2xhdGUoYXhpcywgZGlyZWN0aW9uLCBjb250YWluZXIpIHtcbiAgY29uc3QgdHJhbnNsYXRlID0gYXhpcy5zY3JvbGwgPT09ICd4JyA/IHggOiB5O1xuICBjb25zdCBjb250YWluZXJTdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcbiAgbGV0IGRpc2FibGVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIHgobikge1xuICAgIHJldHVybiBgdHJhbnNsYXRlM2QoJHtufXB4LDBweCwwcHgpYDtcbiAgfVxuICBmdW5jdGlvbiB5KG4pIHtcbiAgICByZXR1cm4gYHRyYW5zbGF0ZTNkKDBweCwke259cHgsMHB4KWA7XG4gIH1cbiAgZnVuY3Rpb24gdG8odGFyZ2V0KSB7XG4gICAgaWYgKGRpc2FibGVkKSByZXR1cm47XG4gICAgY29udGFpbmVyU3R5bGUudHJhbnNmb3JtID0gdHJhbnNsYXRlKGRpcmVjdGlvbi5hcHBseSh0YXJnZXQpKTtcbiAgfVxuICBmdW5jdGlvbiB0b2dnbGVBY3RpdmUoYWN0aXZlKSB7XG4gICAgZGlzYWJsZWQgPSAhYWN0aXZlO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuO1xuICAgIGNvbnRhaW5lclN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuICAgIGlmICghY29udGFpbmVyLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSkgY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGNsZWFyLFxuICAgIHRvLFxuICAgIHRvZ2dsZUFjdGl2ZVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2xpZGVMb29wZXIoYXhpcywgZGlyZWN0aW9uLCB2aWV3U2l6ZSwgY29udGVudFNpemUsIHNsaWRlU2l6ZXMsIHNsaWRlU2l6ZXNXaXRoR2Fwcywgc25hcHMsIHNjcm9sbFNuYXBzLCBvZmZzZXRMb2NhdGlvbiwgc2xpZGVzKSB7XG4gIGNvbnN0IHJvdW5kaW5nU2FmZXR5ID0gMC41O1xuICBjb25zdCBhc2NJdGVtcyA9IGFycmF5S2V5cyhzbGlkZVNpemVzV2l0aEdhcHMpO1xuICBjb25zdCBkZXNjSXRlbXMgPSBhcnJheUtleXMoc2xpZGVTaXplc1dpdGhHYXBzKS5yZXZlcnNlKCk7XG4gIGNvbnN0IGxvb3BQb2ludHMgPSBzdGFydFBvaW50cygpLmNvbmNhdChlbmRQb2ludHMoKSk7XG4gIGZ1bmN0aW9uIHJlbW92ZVNsaWRlU2l6ZXMoaW5kZXhlcywgZnJvbSkge1xuICAgIHJldHVybiBpbmRleGVzLnJlZHVjZSgoYSwgaSkgPT4ge1xuICAgICAgcmV0dXJuIGEgLSBzbGlkZVNpemVzV2l0aEdhcHNbaV07XG4gICAgfSwgZnJvbSk7XG4gIH1cbiAgZnVuY3Rpb24gc2xpZGVzSW5HYXAoaW5kZXhlcywgZ2FwKSB7XG4gICAgcmV0dXJuIGluZGV4ZXMucmVkdWNlKChhLCBpKSA9PiB7XG4gICAgICBjb25zdCByZW1haW5pbmdHYXAgPSByZW1vdmVTbGlkZVNpemVzKGEsIGdhcCk7XG4gICAgICByZXR1cm4gcmVtYWluaW5nR2FwID4gMCA/IGEuY29uY2F0KFtpXSkgOiBhO1xuICAgIH0sIFtdKTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kU2xpZGVCb3VuZHMob2Zmc2V0KSB7XG4gICAgcmV0dXJuIHNuYXBzLm1hcCgoc25hcCwgaW5kZXgpID0+ICh7XG4gICAgICBzdGFydDogc25hcCAtIHNsaWRlU2l6ZXNbaW5kZXhdICsgcm91bmRpbmdTYWZldHkgKyBvZmZzZXQsXG4gICAgICBlbmQ6IHNuYXAgKyB2aWV3U2l6ZSAtIHJvdW5kaW5nU2FmZXR5ICsgb2Zmc2V0XG4gICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmRMb29wUG9pbnRzKGluZGV4ZXMsIG9mZnNldCwgaXNFbmRFZGdlKSB7XG4gICAgY29uc3Qgc2xpZGVCb3VuZHMgPSBmaW5kU2xpZGVCb3VuZHMob2Zmc2V0KTtcbiAgICByZXR1cm4gaW5kZXhlcy5tYXAoaW5kZXggPT4ge1xuICAgICAgY29uc3QgaW5pdGlhbCA9IGlzRW5kRWRnZSA/IDAgOiAtY29udGVudFNpemU7XG4gICAgICBjb25zdCBhbHRlcmVkID0gaXNFbmRFZGdlID8gY29udGVudFNpemUgOiAwO1xuICAgICAgY29uc3QgYm91bmRFZGdlID0gaXNFbmRFZGdlID8gJ2VuZCcgOiAnc3RhcnQnO1xuICAgICAgY29uc3QgbG9vcFBvaW50ID0gc2xpZGVCb3VuZHNbaW5kZXhdW2JvdW5kRWRnZV07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmRleCxcbiAgICAgICAgbG9vcFBvaW50LFxuICAgICAgICBzbGlkZUxvY2F0aW9uOiBWZWN0b3IxRCgtMSksXG4gICAgICAgIHRyYW5zbGF0ZTogVHJhbnNsYXRlKGF4aXMsIGRpcmVjdGlvbiwgc2xpZGVzW2luZGV4XSksXG4gICAgICAgIHRhcmdldDogKCkgPT4gb2Zmc2V0TG9jYXRpb24uZ2V0KCkgPiBsb29wUG9pbnQgPyBpbml0aWFsIDogYWx0ZXJlZFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzdGFydFBvaW50cygpIHtcbiAgICBjb25zdCBnYXAgPSBzY3JvbGxTbmFwc1swXTtcbiAgICBjb25zdCBpbmRleGVzID0gc2xpZGVzSW5HYXAoZGVzY0l0ZW1zLCBnYXApO1xuICAgIHJldHVybiBmaW5kTG9vcFBvaW50cyhpbmRleGVzLCBjb250ZW50U2l6ZSwgZmFsc2UpO1xuICB9XG4gIGZ1bmN0aW9uIGVuZFBvaW50cygpIHtcbiAgICBjb25zdCBnYXAgPSB2aWV3U2l6ZSAtIHNjcm9sbFNuYXBzWzBdIC0gMTtcbiAgICBjb25zdCBpbmRleGVzID0gc2xpZGVzSW5HYXAoYXNjSXRlbXMsIGdhcCk7XG4gICAgcmV0dXJuIGZpbmRMb29wUG9pbnRzKGluZGV4ZXMsIC1jb250ZW50U2l6ZSwgdHJ1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gY2FuTG9vcCgpIHtcbiAgICByZXR1cm4gbG9vcFBvaW50cy5ldmVyeSgoe1xuICAgICAgaW5kZXhcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBvdGhlckluZGV4ZXMgPSBhc2NJdGVtcy5maWx0ZXIoaSA9PiBpICE9PSBpbmRleCk7XG4gICAgICByZXR1cm4gcmVtb3ZlU2xpZGVTaXplcyhvdGhlckluZGV4ZXMsIHZpZXdTaXplKSA8PSAwLjE7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gbG9vcCgpIHtcbiAgICBsb29wUG9pbnRzLmZvckVhY2gobG9vcFBvaW50ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICB0cmFuc2xhdGUsXG4gICAgICAgIHNsaWRlTG9jYXRpb25cbiAgICAgIH0gPSBsb29wUG9pbnQ7XG4gICAgICBjb25zdCBzaGlmdExvY2F0aW9uID0gdGFyZ2V0KCk7XG4gICAgICBpZiAoc2hpZnRMb2NhdGlvbiA9PT0gc2xpZGVMb2NhdGlvbi5nZXQoKSkgcmV0dXJuO1xuICAgICAgdHJhbnNsYXRlLnRvKHNoaWZ0TG9jYXRpb24pO1xuICAgICAgc2xpZGVMb2NhdGlvbi5zZXQoc2hpZnRMb2NhdGlvbik7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgbG9vcFBvaW50cy5mb3JFYWNoKGxvb3BQb2ludCA9PiBsb29wUG9pbnQudHJhbnNsYXRlLmNsZWFyKCkpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgY2FuTG9vcCxcbiAgICBjbGVhcixcbiAgICBsb29wLFxuICAgIGxvb3BQb2ludHNcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNsaWRlc0hhbmRsZXIoY29udGFpbmVyLCBldmVudEhhbmRsZXIsIHdhdGNoU2xpZGVzKSB7XG4gIGxldCBtdXRhdGlvbk9ic2VydmVyO1xuICBsZXQgZGVzdHJveWVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGluaXQoZW1ibGFBcGkpIHtcbiAgICBpZiAoIXdhdGNoU2xpZGVzKSByZXR1cm47XG4gICAgZnVuY3Rpb24gZGVmYXVsdENhbGxiYWNrKG11dGF0aW9ucykge1xuICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgZW1ibGFBcGkucmVJbml0KCk7XG4gICAgICAgICAgZXZlbnRIYW5kbGVyLmVtaXQoJ3NsaWRlc0NoYW5nZWQnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBtdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICAgIGlmIChpc0Jvb2xlYW4od2F0Y2hTbGlkZXMpIHx8IHdhdGNoU2xpZGVzKGVtYmxhQXBpLCBtdXRhdGlvbnMpKSB7XG4gICAgICAgIGRlZmF1bHRDYWxsYmFjayhtdXRhdGlvbnMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXIsIHtcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKG11dGF0aW9uT2JzZXJ2ZXIpIG11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIGRlc3Ryb3llZCA9IHRydWU7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0LFxuICAgIGRlc3Ryb3lcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNsaWRlc0luVmlldyhjb250YWluZXIsIHNsaWRlcywgZXZlbnRIYW5kbGVyLCB0aHJlc2hvbGQpIHtcbiAgY29uc3QgaW50ZXJzZWN0aW9uRW50cnlNYXAgPSB7fTtcbiAgbGV0IGluVmlld0NhY2hlID0gbnVsbDtcbiAgbGV0IG5vdEluVmlld0NhY2hlID0gbnVsbDtcbiAgbGV0IGludGVyc2VjdGlvbk9ic2VydmVyO1xuICBsZXQgZGVzdHJveWVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgICBlbnRyaWVzLmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IHNsaWRlcy5pbmRleE9mKGVudHJ5LnRhcmdldCk7XG4gICAgICAgIGludGVyc2VjdGlvbkVudHJ5TWFwW2luZGV4XSA9IGVudHJ5O1xuICAgICAgfSk7XG4gICAgICBpblZpZXdDYWNoZSA9IG51bGw7XG4gICAgICBub3RJblZpZXdDYWNoZSA9IG51bGw7XG4gICAgICBldmVudEhhbmRsZXIuZW1pdCgnc2xpZGVzSW5WaWV3Jyk7XG4gICAgfSwge1xuICAgICAgcm9vdDogY29udGFpbmVyLnBhcmVudEVsZW1lbnQsXG4gICAgICB0aHJlc2hvbGRcbiAgICB9KTtcbiAgICBzbGlkZXMuZm9yRWFjaChzbGlkZSA9PiBpbnRlcnNlY3Rpb25PYnNlcnZlci5vYnNlcnZlKHNsaWRlKSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpZiAoaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIGludGVyc2VjdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICBkZXN0cm95ZWQgPSB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUluVmlld0xpc3QoaW5WaWV3KSB7XG4gICAgcmV0dXJuIG9iamVjdEtleXMoaW50ZXJzZWN0aW9uRW50cnlNYXApLnJlZHVjZSgobGlzdCwgc2xpZGVJbmRleCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChzbGlkZUluZGV4KTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaXNJbnRlcnNlY3RpbmdcbiAgICAgIH0gPSBpbnRlcnNlY3Rpb25FbnRyeU1hcFtpbmRleF07XG4gICAgICBjb25zdCBpblZpZXdNYXRjaCA9IGluVmlldyAmJiBpc0ludGVyc2VjdGluZztcbiAgICAgIGNvbnN0IG5vdEluVmlld01hdGNoID0gIWluVmlldyAmJiAhaXNJbnRlcnNlY3Rpbmc7XG4gICAgICBpZiAoaW5WaWV3TWF0Y2ggfHwgbm90SW5WaWV3TWF0Y2gpIGxpc3QucHVzaChpbmRleCk7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9LCBbXSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0KGluVmlldyA9IHRydWUpIHtcbiAgICBpZiAoaW5WaWV3ICYmIGluVmlld0NhY2hlKSByZXR1cm4gaW5WaWV3Q2FjaGU7XG4gICAgaWYgKCFpblZpZXcgJiYgbm90SW5WaWV3Q2FjaGUpIHJldHVybiBub3RJblZpZXdDYWNoZTtcbiAgICBjb25zdCBzbGlkZUluZGV4ZXMgPSBjcmVhdGVJblZpZXdMaXN0KGluVmlldyk7XG4gICAgaWYgKGluVmlldykgaW5WaWV3Q2FjaGUgPSBzbGlkZUluZGV4ZXM7XG4gICAgaWYgKCFpblZpZXcpIG5vdEluVmlld0NhY2hlID0gc2xpZGVJbmRleGVzO1xuICAgIHJldHVybiBzbGlkZUluZGV4ZXM7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0LFxuICAgIGRlc3Ryb3ksXG4gICAgZ2V0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTbGlkZVNpemVzKGF4aXMsIGNvbnRhaW5lclJlY3QsIHNsaWRlUmVjdHMsIHNsaWRlcywgcmVhZEVkZ2VHYXAsIG93bmVyV2luZG93KSB7XG4gIGNvbnN0IHtcbiAgICBtZWFzdXJlU2l6ZSxcbiAgICBzdGFydEVkZ2UsXG4gICAgZW5kRWRnZVxuICB9ID0gYXhpcztcbiAgY29uc3Qgd2l0aEVkZ2VHYXAgPSBzbGlkZVJlY3RzWzBdICYmIHJlYWRFZGdlR2FwO1xuICBjb25zdCBzdGFydEdhcCA9IG1lYXN1cmVTdGFydEdhcCgpO1xuICBjb25zdCBlbmRHYXAgPSBtZWFzdXJlRW5kR2FwKCk7XG4gIGNvbnN0IHNsaWRlU2l6ZXMgPSBzbGlkZVJlY3RzLm1hcChtZWFzdXJlU2l6ZSk7XG4gIGNvbnN0IHNsaWRlU2l6ZXNXaXRoR2FwcyA9IG1lYXN1cmVXaXRoR2FwcygpO1xuICBmdW5jdGlvbiBtZWFzdXJlU3RhcnRHYXAoKSB7XG4gICAgaWYgKCF3aXRoRWRnZUdhcCkgcmV0dXJuIDA7XG4gICAgY29uc3Qgc2xpZGVSZWN0ID0gc2xpZGVSZWN0c1swXTtcbiAgICByZXR1cm4gbWF0aEFicyhjb250YWluZXJSZWN0W3N0YXJ0RWRnZV0gLSBzbGlkZVJlY3Rbc3RhcnRFZGdlXSk7XG4gIH1cbiAgZnVuY3Rpb24gbWVhc3VyZUVuZEdhcCgpIHtcbiAgICBpZiAoIXdpdGhFZGdlR2FwKSByZXR1cm4gMDtcbiAgICBjb25zdCBzdHlsZSA9IG93bmVyV2luZG93LmdldENvbXB1dGVkU3R5bGUoYXJyYXlMYXN0KHNsaWRlcykpO1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoYG1hcmdpbi0ke2VuZEVkZ2V9YCkpO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmVXaXRoR2FwcygpIHtcbiAgICByZXR1cm4gc2xpZGVSZWN0cy5tYXAoKHJlY3QsIGluZGV4LCByZWN0cykgPT4ge1xuICAgICAgY29uc3QgaXNGaXJzdCA9ICFpbmRleDtcbiAgICAgIGNvbnN0IGlzTGFzdCA9IGFycmF5SXNMYXN0SW5kZXgocmVjdHMsIGluZGV4KTtcbiAgICAgIGlmIChpc0ZpcnN0KSByZXR1cm4gc2xpZGVTaXplc1tpbmRleF0gKyBzdGFydEdhcDtcbiAgICAgIGlmIChpc0xhc3QpIHJldHVybiBzbGlkZVNpemVzW2luZGV4XSArIGVuZEdhcDtcbiAgICAgIHJldHVybiByZWN0c1tpbmRleCArIDFdW3N0YXJ0RWRnZV0gLSByZWN0W3N0YXJ0RWRnZV07XG4gICAgfSkubWFwKG1hdGhBYnMpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgc2xpZGVTaXplcyxcbiAgICBzbGlkZVNpemVzV2l0aEdhcHMsXG4gICAgc3RhcnRHYXAsXG4gICAgZW5kR2FwXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTbGlkZXNUb1Njcm9sbChheGlzLCBkaXJlY3Rpb24sIHZpZXdTaXplLCBzbGlkZXNUb1Njcm9sbCwgbG9vcCwgY29udGFpbmVyUmVjdCwgc2xpZGVSZWN0cywgc3RhcnRHYXAsIGVuZEdhcCwgcGl4ZWxUb2xlcmFuY2UpIHtcbiAgY29uc3Qge1xuICAgIHN0YXJ0RWRnZSxcbiAgICBlbmRFZGdlXG4gIH0gPSBheGlzO1xuICBjb25zdCBncm91cEJ5TnVtYmVyID0gaXNOdW1iZXIoc2xpZGVzVG9TY3JvbGwpO1xuICBmdW5jdGlvbiBieU51bWJlcihhcnJheSwgZ3JvdXBTaXplKSB7XG4gICAgcmV0dXJuIGFycmF5S2V5cyhhcnJheSkuZmlsdGVyKGkgPT4gaSAlIGdyb3VwU2l6ZSA9PT0gMCkubWFwKGkgPT4gYXJyYXkuc2xpY2UoaSwgaSArIGdyb3VwU2l6ZSkpO1xuICB9XG4gIGZ1bmN0aW9uIGJ5U2l6ZShhcnJheSkge1xuICAgIGlmICghYXJyYXkubGVuZ3RoKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFycmF5S2V5cyhhcnJheSkucmVkdWNlKChncm91cHMsIHJlY3RCKSA9PiB7XG4gICAgICBjb25zdCByZWN0QSA9IGFycmF5TGFzdChncm91cHMpIHx8IDA7XG4gICAgICBjb25zdCBpc0ZpcnN0ID0gcmVjdEEgPT09IDA7XG4gICAgICBjb25zdCBpc0xhc3QgPSByZWN0QiA9PT0gYXJyYXlMYXN0SW5kZXgoYXJyYXkpO1xuICAgICAgY29uc3QgZWRnZUEgPSBjb250YWluZXJSZWN0W3N0YXJ0RWRnZV0gLSBzbGlkZVJlY3RzW3JlY3RBXVtzdGFydEVkZ2VdO1xuICAgICAgY29uc3QgZWRnZUIgPSBjb250YWluZXJSZWN0W3N0YXJ0RWRnZV0gLSBzbGlkZVJlY3RzW3JlY3RCXVtlbmRFZGdlXTtcbiAgICAgIGNvbnN0IGdhcEEgPSAhbG9vcCAmJiBpc0ZpcnN0ID8gZGlyZWN0aW9uLmFwcGx5KHN0YXJ0R2FwKSA6IDA7XG4gICAgICBjb25zdCBnYXBCID0gIWxvb3AgJiYgaXNMYXN0ID8gZGlyZWN0aW9uLmFwcGx5KGVuZEdhcCkgOiAwO1xuICAgICAgY29uc3QgY2h1bmtTaXplID0gbWF0aEFicyhlZGdlQiAtIGdhcEIgLSAoZWRnZUEgKyBnYXBBKSk7XG4gICAgICBpZiAoY2h1bmtTaXplID4gdmlld1NpemUgKyBwaXhlbFRvbGVyYW5jZSkgZ3JvdXBzLnB1c2gocmVjdEIpO1xuICAgICAgaWYgKGlzTGFzdCkgZ3JvdXBzLnB1c2goYXJyYXkubGVuZ3RoKTtcbiAgICAgIHJldHVybiBncm91cHM7XG4gICAgfSwgW10pLm1hcCgoY3VycmVudFNpemUsIGluZGV4LCBncm91cHMpID0+IHtcbiAgICAgIGNvbnN0IHByZXZpb3VzU2l6ZSA9IE1hdGgubWF4KGdyb3Vwc1tpbmRleCAtIDFdIHx8IDApO1xuICAgICAgcmV0dXJuIGFycmF5LnNsaWNlKHByZXZpb3VzU2l6ZSwgY3VycmVudFNpemUpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGdyb3VwU2xpZGVzKGFycmF5KSB7XG4gICAgcmV0dXJuIGdyb3VwQnlOdW1iZXIgPyBieU51bWJlcihhcnJheSwgc2xpZGVzVG9TY3JvbGwpIDogYnlTaXplKGFycmF5KTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGdyb3VwU2xpZGVzXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBFbmdpbmUocm9vdCwgY29udGFpbmVyLCBzbGlkZXMsIG93bmVyRG9jdW1lbnQsIG93bmVyV2luZG93LCBvcHRpb25zLCBldmVudEhhbmRsZXIpIHtcbiAgLy8gT3B0aW9uc1xuICBjb25zdCB7XG4gICAgYWxpZ24sXG4gICAgYXhpczogc2Nyb2xsQXhpcyxcbiAgICBkaXJlY3Rpb246IGNvbnRlbnREaXJlY3Rpb24sXG4gICAgc3RhcnRJbmRleCxcbiAgICBsb29wLFxuICAgIGR1cmF0aW9uLFxuICAgIGRyYWdGcmVlLFxuICAgIGRyYWdUaHJlc2hvbGQsXG4gICAgaW5WaWV3VGhyZXNob2xkLFxuICAgIHNsaWRlc1RvU2Nyb2xsOiBncm91cFNsaWRlcyxcbiAgICBza2lwU25hcHMsXG4gICAgY29udGFpblNjcm9sbCxcbiAgICB3YXRjaFJlc2l6ZSxcbiAgICB3YXRjaFNsaWRlcyxcbiAgICB3YXRjaERyYWdcbiAgfSA9IG9wdGlvbnM7XG4gIC8vIE1lYXN1cmVtZW50c1xuICBjb25zdCBwaXhlbFRvbGVyYW5jZSA9IDI7XG4gIGNvbnN0IG5vZGVSZWN0cyA9IE5vZGVSZWN0cygpO1xuICBjb25zdCBjb250YWluZXJSZWN0ID0gbm9kZVJlY3RzLm1lYXN1cmUoY29udGFpbmVyKTtcbiAgY29uc3Qgc2xpZGVSZWN0cyA9IHNsaWRlcy5tYXAobm9kZVJlY3RzLm1lYXN1cmUpO1xuICBjb25zdCBkaXJlY3Rpb24gPSBEaXJlY3Rpb24oY29udGVudERpcmVjdGlvbik7XG4gIGNvbnN0IGF4aXMgPSBBeGlzKHNjcm9sbEF4aXMsIGNvbnRlbnREaXJlY3Rpb24pO1xuICBjb25zdCB2aWV3U2l6ZSA9IGF4aXMubWVhc3VyZVNpemUoY29udGFpbmVyUmVjdCk7XG4gIGNvbnN0IHBlcmNlbnRPZlZpZXcgPSBQZXJjZW50T2ZWaWV3KHZpZXdTaXplKTtcbiAgY29uc3QgYWxpZ25tZW50ID0gQWxpZ25tZW50KGFsaWduLCB2aWV3U2l6ZSk7XG4gIGNvbnN0IGNvbnRhaW5TbmFwcyA9ICFsb29wICYmICEhY29udGFpblNjcm9sbDtcbiAgY29uc3QgcmVhZEVkZ2VHYXAgPSBsb29wIHx8ICEhY29udGFpblNjcm9sbDtcbiAgY29uc3Qge1xuICAgIHNsaWRlU2l6ZXMsXG4gICAgc2xpZGVTaXplc1dpdGhHYXBzLFxuICAgIHN0YXJ0R2FwLFxuICAgIGVuZEdhcFxuICB9ID0gU2xpZGVTaXplcyhheGlzLCBjb250YWluZXJSZWN0LCBzbGlkZVJlY3RzLCBzbGlkZXMsIHJlYWRFZGdlR2FwLCBvd25lcldpbmRvdyk7XG4gIGNvbnN0IHNsaWRlc1RvU2Nyb2xsID0gU2xpZGVzVG9TY3JvbGwoYXhpcywgZGlyZWN0aW9uLCB2aWV3U2l6ZSwgZ3JvdXBTbGlkZXMsIGxvb3AsIGNvbnRhaW5lclJlY3QsIHNsaWRlUmVjdHMsIHN0YXJ0R2FwLCBlbmRHYXAsIHBpeGVsVG9sZXJhbmNlKTtcbiAgY29uc3Qge1xuICAgIHNuYXBzLFxuICAgIHNuYXBzQWxpZ25lZFxuICB9ID0gU2Nyb2xsU25hcHMoYXhpcywgYWxpZ25tZW50LCBjb250YWluZXJSZWN0LCBzbGlkZVJlY3RzLCBzbGlkZXNUb1Njcm9sbCk7XG4gIGNvbnN0IGNvbnRlbnRTaXplID0gLWFycmF5TGFzdChzbmFwcykgKyBhcnJheUxhc3Qoc2xpZGVTaXplc1dpdGhHYXBzKTtcbiAgY29uc3Qge1xuICAgIHNuYXBzQ29udGFpbmVkLFxuICAgIHNjcm9sbENvbnRhaW5MaW1pdFxuICB9ID0gU2Nyb2xsQ29udGFpbih2aWV3U2l6ZSwgY29udGVudFNpemUsIHNuYXBzQWxpZ25lZCwgY29udGFpblNjcm9sbCwgcGl4ZWxUb2xlcmFuY2UpO1xuICBjb25zdCBzY3JvbGxTbmFwcyA9IGNvbnRhaW5TbmFwcyA/IHNuYXBzQ29udGFpbmVkIDogc25hcHNBbGlnbmVkO1xuICBjb25zdCB7XG4gICAgbGltaXRcbiAgfSA9IFNjcm9sbExpbWl0KGNvbnRlbnRTaXplLCBzY3JvbGxTbmFwcywgbG9vcCk7XG4gIC8vIEluZGV4ZXNcbiAgY29uc3QgaW5kZXggPSBDb3VudGVyKGFycmF5TGFzdEluZGV4KHNjcm9sbFNuYXBzKSwgc3RhcnRJbmRleCwgbG9vcCk7XG4gIGNvbnN0IGluZGV4UHJldmlvdXMgPSBpbmRleC5jbG9uZSgpO1xuICBjb25zdCBzbGlkZUluZGV4ZXMgPSBhcnJheUtleXMoc2xpZGVzKTtcbiAgLy8gQW5pbWF0aW9uXG4gIGNvbnN0IHVwZGF0ZSA9ICh7XG4gICAgZHJhZ0hhbmRsZXIsXG4gICAgc2Nyb2xsQm9keSxcbiAgICBzY3JvbGxCb3VuZHMsXG4gICAgb3B0aW9uczoge1xuICAgICAgbG9vcFxuICAgIH1cbiAgfSkgPT4ge1xuICAgIGlmICghbG9vcCkgc2Nyb2xsQm91bmRzLmNvbnN0cmFpbihkcmFnSGFuZGxlci5wb2ludGVyRG93bigpKTtcbiAgICBzY3JvbGxCb2R5LnNlZWsoKTtcbiAgfTtcbiAgY29uc3QgcmVuZGVyID0gKHtcbiAgICBzY3JvbGxCb2R5LFxuICAgIHRyYW5zbGF0ZSxcbiAgICBsb2NhdGlvbixcbiAgICBvZmZzZXRMb2NhdGlvbixcbiAgICBzY3JvbGxMb29wZXIsXG4gICAgc2xpZGVMb29wZXIsXG4gICAgZHJhZ0hhbmRsZXIsXG4gICAgYW5pbWF0aW9uLFxuICAgIGV2ZW50SGFuZGxlcixcbiAgICBvcHRpb25zOiB7XG4gICAgICBsb29wXG4gICAgfVxuICB9LCBsYWdPZmZzZXQpID0+IHtcbiAgICBjb25zdCB2ZWxvY2l0eSA9IHNjcm9sbEJvZHkudmVsb2NpdHkoKTtcbiAgICBjb25zdCBoYXNTZXR0bGVkID0gc2Nyb2xsQm9keS5zZXR0bGVkKCk7XG4gICAgaWYgKGhhc1NldHRsZWQgJiYgIWRyYWdIYW5kbGVyLnBvaW50ZXJEb3duKCkpIHtcbiAgICAgIGFuaW1hdGlvbi5zdG9wKCk7XG4gICAgICBldmVudEhhbmRsZXIuZW1pdCgnc2V0dGxlJyk7XG4gICAgfVxuICAgIGlmICghaGFzU2V0dGxlZCkgZXZlbnRIYW5kbGVyLmVtaXQoJ3Njcm9sbCcpO1xuICAgIG9mZnNldExvY2F0aW9uLnNldChsb2NhdGlvbi5nZXQoKSAtIHZlbG9jaXR5ICsgdmVsb2NpdHkgKiBsYWdPZmZzZXQpO1xuICAgIGlmIChsb29wKSB7XG4gICAgICBzY3JvbGxMb29wZXIubG9vcChzY3JvbGxCb2R5LmRpcmVjdGlvbigpKTtcbiAgICAgIHNsaWRlTG9vcGVyLmxvb3AoKTtcbiAgICB9XG4gICAgdHJhbnNsYXRlLnRvKG9mZnNldExvY2F0aW9uLmdldCgpKTtcbiAgfTtcbiAgY29uc3QgYW5pbWF0aW9uID0gQW5pbWF0aW9ucyhvd25lckRvY3VtZW50LCBvd25lcldpbmRvdywgKCkgPT4gdXBkYXRlKGVuZ2luZSksIGxhZ09mZnNldCA9PiByZW5kZXIoZW5naW5lLCBsYWdPZmZzZXQpKTtcbiAgLy8gU2hhcmVkXG4gIGNvbnN0IGZyaWN0aW9uID0gMC42ODtcbiAgY29uc3Qgc3RhcnRMb2NhdGlvbiA9IHNjcm9sbFNuYXBzW2luZGV4LmdldCgpXTtcbiAgY29uc3QgbG9jYXRpb24gPSBWZWN0b3IxRChzdGFydExvY2F0aW9uKTtcbiAgY29uc3Qgb2Zmc2V0TG9jYXRpb24gPSBWZWN0b3IxRChzdGFydExvY2F0aW9uKTtcbiAgY29uc3QgdGFyZ2V0ID0gVmVjdG9yMUQoc3RhcnRMb2NhdGlvbik7XG4gIGNvbnN0IHNjcm9sbEJvZHkgPSBTY3JvbGxCb2R5KGxvY2F0aW9uLCBvZmZzZXRMb2NhdGlvbiwgdGFyZ2V0LCBkdXJhdGlvbiwgZnJpY3Rpb24pO1xuICBjb25zdCBzY3JvbGxUYXJnZXQgPSBTY3JvbGxUYXJnZXQobG9vcCwgc2Nyb2xsU25hcHMsIGNvbnRlbnRTaXplLCBsaW1pdCwgdGFyZ2V0KTtcbiAgY29uc3Qgc2Nyb2xsVG8gPSBTY3JvbGxUbyhhbmltYXRpb24sIGluZGV4LCBpbmRleFByZXZpb3VzLCBzY3JvbGxCb2R5LCBzY3JvbGxUYXJnZXQsIHRhcmdldCwgZXZlbnRIYW5kbGVyKTtcbiAgY29uc3Qgc2Nyb2xsUHJvZ3Jlc3MgPSBTY3JvbGxQcm9ncmVzcyhsaW1pdCk7XG4gIGNvbnN0IGV2ZW50U3RvcmUgPSBFdmVudFN0b3JlKCk7XG4gIGNvbnN0IHNsaWRlc0luVmlldyA9IFNsaWRlc0luVmlldyhjb250YWluZXIsIHNsaWRlcywgZXZlbnRIYW5kbGVyLCBpblZpZXdUaHJlc2hvbGQpO1xuICBjb25zdCB7XG4gICAgc2xpZGVSZWdpc3RyeVxuICB9ID0gU2xpZGVSZWdpc3RyeShjb250YWluU25hcHMsIGNvbnRhaW5TY3JvbGwsIHNjcm9sbFNuYXBzLCBzY3JvbGxDb250YWluTGltaXQsIHNsaWRlc1RvU2Nyb2xsLCBzbGlkZUluZGV4ZXMpO1xuICBjb25zdCBzbGlkZUZvY3VzID0gU2xpZGVGb2N1cyhyb290LCBzbGlkZXMsIHNsaWRlUmVnaXN0cnksIHNjcm9sbFRvLCBzY3JvbGxCb2R5LCBldmVudFN0b3JlKTtcbiAgLy8gRW5naW5lXG4gIGNvbnN0IGVuZ2luZSA9IHtcbiAgICBvd25lckRvY3VtZW50LFxuICAgIG93bmVyV2luZG93LFxuICAgIGV2ZW50SGFuZGxlcixcbiAgICBjb250YWluZXJSZWN0LFxuICAgIHNsaWRlUmVjdHMsXG4gICAgYW5pbWF0aW9uLFxuICAgIGF4aXMsXG4gICAgZGlyZWN0aW9uLFxuICAgIGRyYWdIYW5kbGVyOiBEcmFnSGFuZGxlcihheGlzLCBkaXJlY3Rpb24sIHJvb3QsIG93bmVyRG9jdW1lbnQsIG93bmVyV2luZG93LCB0YXJnZXQsIERyYWdUcmFja2VyKGF4aXMsIG93bmVyV2luZG93KSwgbG9jYXRpb24sIGFuaW1hdGlvbiwgc2Nyb2xsVG8sIHNjcm9sbEJvZHksIHNjcm9sbFRhcmdldCwgaW5kZXgsIGV2ZW50SGFuZGxlciwgcGVyY2VudE9mVmlldywgZHJhZ0ZyZWUsIGRyYWdUaHJlc2hvbGQsIHNraXBTbmFwcywgZnJpY3Rpb24sIHdhdGNoRHJhZyksXG4gICAgZXZlbnRTdG9yZSxcbiAgICBwZXJjZW50T2ZWaWV3LFxuICAgIGluZGV4LFxuICAgIGluZGV4UHJldmlvdXMsXG4gICAgbGltaXQsXG4gICAgbG9jYXRpb24sXG4gICAgb2Zmc2V0TG9jYXRpb24sXG4gICAgb3B0aW9ucyxcbiAgICByZXNpemVIYW5kbGVyOiBSZXNpemVIYW5kbGVyKGNvbnRhaW5lciwgZXZlbnRIYW5kbGVyLCBvd25lcldpbmRvdywgc2xpZGVzLCBheGlzLCB3YXRjaFJlc2l6ZSwgbm9kZVJlY3RzKSxcbiAgICBzY3JvbGxCb2R5LFxuICAgIHNjcm9sbEJvdW5kczogU2Nyb2xsQm91bmRzKGxpbWl0LCBsb2NhdGlvbiwgdGFyZ2V0LCBzY3JvbGxCb2R5LCBwZXJjZW50T2ZWaWV3KSxcbiAgICBzY3JvbGxMb29wZXI6IFNjcm9sbExvb3Blcihjb250ZW50U2l6ZSwgbGltaXQsIG9mZnNldExvY2F0aW9uLCBbbG9jYXRpb24sIG9mZnNldExvY2F0aW9uLCB0YXJnZXRdKSxcbiAgICBzY3JvbGxQcm9ncmVzcyxcbiAgICBzY3JvbGxTbmFwTGlzdDogc2Nyb2xsU25hcHMubWFwKHNjcm9sbFByb2dyZXNzLmdldCksXG4gICAgc2Nyb2xsU25hcHMsXG4gICAgc2Nyb2xsVGFyZ2V0LFxuICAgIHNjcm9sbFRvLFxuICAgIHNsaWRlTG9vcGVyOiBTbGlkZUxvb3BlcihheGlzLCBkaXJlY3Rpb24sIHZpZXdTaXplLCBjb250ZW50U2l6ZSwgc2xpZGVTaXplcywgc2xpZGVTaXplc1dpdGhHYXBzLCBzbmFwcywgc2Nyb2xsU25hcHMsIG9mZnNldExvY2F0aW9uLCBzbGlkZXMpLFxuICAgIHNsaWRlRm9jdXMsXG4gICAgc2xpZGVzSGFuZGxlcjogU2xpZGVzSGFuZGxlcihjb250YWluZXIsIGV2ZW50SGFuZGxlciwgd2F0Y2hTbGlkZXMpLFxuICAgIHNsaWRlc0luVmlldyxcbiAgICBzbGlkZUluZGV4ZXMsXG4gICAgc2xpZGVSZWdpc3RyeSxcbiAgICBzbGlkZXNUb1Njcm9sbCxcbiAgICB0YXJnZXQsXG4gICAgdHJhbnNsYXRlOiBUcmFuc2xhdGUoYXhpcywgZGlyZWN0aW9uLCBjb250YWluZXIpXG4gIH07XG4gIHJldHVybiBlbmdpbmU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50SGFuZGxlcigpIHtcbiAgY29uc3QgbGlzdGVuZXJzID0ge307XG4gIGxldCBhcGk7XG4gIGZ1bmN0aW9uIGluaXQoZW1ibGFBcGkpIHtcbiAgICBhcGkgPSBlbWJsYUFwaTtcbiAgfVxuICBmdW5jdGlvbiBnZXRMaXN0ZW5lcnMoZXZ0KSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyc1tldnRdIHx8IFtdO1xuICB9XG4gIGZ1bmN0aW9uIGVtaXQoZXZ0KSB7XG4gICAgZ2V0TGlzdGVuZXJzKGV2dCkuZm9yRWFjaChlID0+IGUoYXBpLCBldnQpKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBmdW5jdGlvbiBvbihldnQsIGNiKSB7XG4gICAgbGlzdGVuZXJzW2V2dF0gPSBnZXRMaXN0ZW5lcnMoZXZ0KS5jb25jYXQoW2NiXSk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZnVuY3Rpb24gb2ZmKGV2dCwgY2IpIHtcbiAgICBsaXN0ZW5lcnNbZXZ0XSA9IGdldExpc3RlbmVycyhldnQpLmZpbHRlcihlID0+IGUgIT09IGNiKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXQsXG4gICAgZW1pdCxcbiAgICBvZmYsXG4gICAgb25cbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBhbGlnbjogJ2NlbnRlcicsXG4gIGF4aXM6ICd4JyxcbiAgY29udGFpbmVyOiBudWxsLFxuICBzbGlkZXM6IG51bGwsXG4gIGNvbnRhaW5TY3JvbGw6ICd0cmltU25hcHMnLFxuICBkaXJlY3Rpb246ICdsdHInLFxuICBzbGlkZXNUb1Njcm9sbDogMSxcbiAgaW5WaWV3VGhyZXNob2xkOiAwLFxuICBicmVha3BvaW50czoge30sXG4gIGRyYWdGcmVlOiBmYWxzZSxcbiAgZHJhZ1RocmVzaG9sZDogMTAsXG4gIGxvb3A6IGZhbHNlLFxuICBza2lwU25hcHM6IGZhbHNlLFxuICBkdXJhdGlvbjogMjUsXG4gIHN0YXJ0SW5kZXg6IDAsXG4gIGFjdGl2ZTogdHJ1ZSxcbiAgd2F0Y2hEcmFnOiB0cnVlLFxuICB3YXRjaFJlc2l6ZTogdHJ1ZSxcbiAgd2F0Y2hTbGlkZXM6IHRydWVcbn07XG5cbmZ1bmN0aW9uIE9wdGlvbnNIYW5kbGVyKG93bmVyV2luZG93KSB7XG4gIGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvcHRpb25zQSwgb3B0aW9uc0IpIHtcbiAgICByZXR1cm4gb2JqZWN0c01lcmdlRGVlcChvcHRpb25zQSwgb3B0aW9uc0IgfHwge30pO1xuICB9XG4gIGZ1bmN0aW9uIG9wdGlvbnNBdE1lZGlhKG9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRpb25zQXRNZWRpYSA9IG9wdGlvbnMuYnJlYWtwb2ludHMgfHwge307XG4gICAgY29uc3QgbWF0Y2hlZE1lZGlhT3B0aW9ucyA9IG9iamVjdEtleXMob3B0aW9uc0F0TWVkaWEpLmZpbHRlcihtZWRpYSA9PiBvd25lcldpbmRvdy5tYXRjaE1lZGlhKG1lZGlhKS5tYXRjaGVzKS5tYXAobWVkaWEgPT4gb3B0aW9uc0F0TWVkaWFbbWVkaWFdKS5yZWR1Y2UoKGEsIG1lZGlhT3B0aW9uKSA9PiBtZXJnZU9wdGlvbnMoYSwgbWVkaWFPcHRpb24pLCB7fSk7XG4gICAgcmV0dXJuIG1lcmdlT3B0aW9ucyhvcHRpb25zLCBtYXRjaGVkTWVkaWFPcHRpb25zKTtcbiAgfVxuICBmdW5jdGlvbiBvcHRpb25zTWVkaWFRdWVyaWVzKG9wdGlvbnNMaXN0KSB7XG4gICAgcmV0dXJuIG9wdGlvbnNMaXN0Lm1hcChvcHRpb25zID0+IG9iamVjdEtleXMob3B0aW9ucy5icmVha3BvaW50cyB8fCB7fSkpLnJlZHVjZSgoYWNjLCBtZWRpYVF1ZXJpZXMpID0+IGFjYy5jb25jYXQobWVkaWFRdWVyaWVzKSwgW10pLm1hcChvd25lcldpbmRvdy5tYXRjaE1lZGlhKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIG1lcmdlT3B0aW9ucyxcbiAgICBvcHRpb25zQXRNZWRpYSxcbiAgICBvcHRpb25zTWVkaWFRdWVyaWVzXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBQbHVnaW5zSGFuZGxlcihvcHRpb25zSGFuZGxlcikge1xuICBsZXQgYWN0aXZlUGx1Z2lucyA9IFtdO1xuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpLCBwbHVnaW5zKSB7XG4gICAgYWN0aXZlUGx1Z2lucyA9IHBsdWdpbnMuZmlsdGVyKCh7XG4gICAgICBvcHRpb25zXG4gICAgfSkgPT4gb3B0aW9uc0hhbmRsZXIub3B0aW9uc0F0TWVkaWEob3B0aW9ucykuYWN0aXZlICE9PSBmYWxzZSk7XG4gICAgYWN0aXZlUGx1Z2lucy5mb3JFYWNoKHBsdWdpbiA9PiBwbHVnaW4uaW5pdChlbWJsYUFwaSwgb3B0aW9uc0hhbmRsZXIpKTtcbiAgICByZXR1cm4gcGx1Z2lucy5yZWR1Y2UoKG1hcCwgcGx1Z2luKSA9PiBPYmplY3QuYXNzaWduKG1hcCwge1xuICAgICAgW3BsdWdpbi5uYW1lXTogcGx1Z2luXG4gICAgfSksIHt9KTtcbiAgfVxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGFjdGl2ZVBsdWdpbnMgPSBhY3RpdmVQbHVnaW5zLmZpbHRlcihwbHVnaW4gPT4gcGx1Z2luLmRlc3Ryb3koKSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0LFxuICAgIGRlc3Ryb3lcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIEVtYmxhQ2Fyb3VzZWwocm9vdCwgdXNlck9wdGlvbnMsIHVzZXJQbHVnaW5zKSB7XG4gIGNvbnN0IG93bmVyRG9jdW1lbnQgPSByb290Lm93bmVyRG9jdW1lbnQ7XG4gIGNvbnN0IG93bmVyV2luZG93ID0gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgY29uc3Qgb3B0aW9uc0hhbmRsZXIgPSBPcHRpb25zSGFuZGxlcihvd25lcldpbmRvdyk7XG4gIGNvbnN0IHBsdWdpbnNIYW5kbGVyID0gUGx1Z2luc0hhbmRsZXIob3B0aW9uc0hhbmRsZXIpO1xuICBjb25zdCBtZWRpYUhhbmRsZXJzID0gRXZlbnRTdG9yZSgpO1xuICBjb25zdCBldmVudEhhbmRsZXIgPSBFdmVudEhhbmRsZXIoKTtcbiAgY29uc3Qge1xuICAgIG1lcmdlT3B0aW9ucyxcbiAgICBvcHRpb25zQXRNZWRpYSxcbiAgICBvcHRpb25zTWVkaWFRdWVyaWVzXG4gIH0gPSBvcHRpb25zSGFuZGxlcjtcbiAgY29uc3Qge1xuICAgIG9uLFxuICAgIG9mZixcbiAgICBlbWl0XG4gIH0gPSBldmVudEhhbmRsZXI7XG4gIGNvbnN0IHJlSW5pdCA9IHJlQWN0aXZhdGU7XG4gIGxldCBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgbGV0IGVuZ2luZTtcbiAgbGV0IG9wdGlvbnNCYXNlID0gbWVyZ2VPcHRpb25zKGRlZmF1bHRPcHRpb25zLCBFbWJsYUNhcm91c2VsLmdsb2JhbE9wdGlvbnMpO1xuICBsZXQgb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhvcHRpb25zQmFzZSk7XG4gIGxldCBwbHVnaW5MaXN0ID0gW107XG4gIGxldCBwbHVnaW5BcGlzO1xuICBsZXQgY29udGFpbmVyO1xuICBsZXQgc2xpZGVzO1xuICBmdW5jdGlvbiBzdG9yZUVsZW1lbnRzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRhaW5lcjogdXNlckNvbnRhaW5lcixcbiAgICAgIHNsaWRlczogdXNlclNsaWRlc1xuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGN1c3RvbUNvbnRhaW5lciA9IGlzU3RyaW5nKHVzZXJDb250YWluZXIpID8gcm9vdC5xdWVyeVNlbGVjdG9yKHVzZXJDb250YWluZXIpIDogdXNlckNvbnRhaW5lcjtcbiAgICBjb250YWluZXIgPSBjdXN0b21Db250YWluZXIgfHwgcm9vdC5jaGlsZHJlblswXTtcbiAgICBjb25zdCBjdXN0b21TbGlkZXMgPSBpc1N0cmluZyh1c2VyU2xpZGVzKSA/IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKHVzZXJTbGlkZXMpIDogdXNlclNsaWRlcztcbiAgICBzbGlkZXMgPSBbXS5zbGljZS5jYWxsKGN1c3RvbVNsaWRlcyB8fCBjb250YWluZXIuY2hpbGRyZW4pO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUVuZ2luZShvcHRpb25zKSB7XG4gICAgY29uc3QgZW5naW5lID0gRW5naW5lKHJvb3QsIGNvbnRhaW5lciwgc2xpZGVzLCBvd25lckRvY3VtZW50LCBvd25lcldpbmRvdywgb3B0aW9ucywgZXZlbnRIYW5kbGVyKTtcbiAgICBpZiAob3B0aW9ucy5sb29wICYmICFlbmdpbmUuc2xpZGVMb29wZXIuY2FuTG9vcCgpKSB7XG4gICAgICBjb25zdCBvcHRpb25zV2l0aG91dExvb3AgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIGxvb3A6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjcmVhdGVFbmdpbmUob3B0aW9uc1dpdGhvdXRMb29wKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuZ2luZTtcbiAgfVxuICBmdW5jdGlvbiBhY3RpdmF0ZSh3aXRoT3B0aW9ucywgd2l0aFBsdWdpbnMpIHtcbiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgb3B0aW9uc0Jhc2UgPSBtZXJnZU9wdGlvbnMob3B0aW9uc0Jhc2UsIHdpdGhPcHRpb25zKTtcbiAgICBvcHRpb25zID0gb3B0aW9uc0F0TWVkaWEob3B0aW9uc0Jhc2UpO1xuICAgIHBsdWdpbkxpc3QgPSB3aXRoUGx1Z2lucyB8fCBwbHVnaW5MaXN0O1xuICAgIHN0b3JlRWxlbWVudHMoKTtcbiAgICBlbmdpbmUgPSBjcmVhdGVFbmdpbmUob3B0aW9ucyk7XG4gICAgb3B0aW9uc01lZGlhUXVlcmllcyhbb3B0aW9uc0Jhc2UsIC4uLnBsdWdpbkxpc3QubWFwKCh7XG4gICAgICBvcHRpb25zXG4gICAgfSkgPT4gb3B0aW9ucyldKS5mb3JFYWNoKHF1ZXJ5ID0+IG1lZGlhSGFuZGxlcnMuYWRkKHF1ZXJ5LCAnY2hhbmdlJywgcmVBY3RpdmF0ZSkpO1xuICAgIGlmICghb3B0aW9ucy5hY3RpdmUpIHJldHVybjtcbiAgICBlbmdpbmUudHJhbnNsYXRlLnRvKGVuZ2luZS5sb2NhdGlvbi5nZXQoKSk7XG4gICAgZW5naW5lLmFuaW1hdGlvbi5pbml0KCk7XG4gICAgZW5naW5lLnNsaWRlc0luVmlldy5pbml0KCk7XG4gICAgZW5naW5lLnNsaWRlRm9jdXMuaW5pdCgpO1xuICAgIGVuZ2luZS5ldmVudEhhbmRsZXIuaW5pdChzZWxmKTtcbiAgICBlbmdpbmUucmVzaXplSGFuZGxlci5pbml0KHNlbGYpO1xuICAgIGVuZ2luZS5zbGlkZXNIYW5kbGVyLmluaXQoc2VsZik7XG4gICAgaWYgKGVuZ2luZS5vcHRpb25zLmxvb3ApIGVuZ2luZS5zbGlkZUxvb3Blci5sb29wKCk7XG4gICAgaWYgKGNvbnRhaW5lci5vZmZzZXRQYXJlbnQgJiYgc2xpZGVzLmxlbmd0aCkgZW5naW5lLmRyYWdIYW5kbGVyLmluaXQoc2VsZik7XG4gICAgcGx1Z2luQXBpcyA9IHBsdWdpbnNIYW5kbGVyLmluaXQoc2VsZiwgcGx1Z2luTGlzdCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVBY3RpdmF0ZSh3aXRoT3B0aW9ucywgd2l0aFBsdWdpbnMpIHtcbiAgICBjb25zdCBzdGFydEluZGV4ID0gc2VsZWN0ZWRTY3JvbGxTbmFwKCk7XG4gICAgZGVBY3RpdmF0ZSgpO1xuICAgIGFjdGl2YXRlKG1lcmdlT3B0aW9ucyh7XG4gICAgICBzdGFydEluZGV4XG4gICAgfSwgd2l0aE9wdGlvbnMpLCB3aXRoUGx1Z2lucyk7XG4gICAgZXZlbnRIYW5kbGVyLmVtaXQoJ3JlSW5pdCcpO1xuICB9XG4gIGZ1bmN0aW9uIGRlQWN0aXZhdGUoKSB7XG4gICAgZW5naW5lLmRyYWdIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICBlbmdpbmUuZXZlbnRTdG9yZS5jbGVhcigpO1xuICAgIGVuZ2luZS50cmFuc2xhdGUuY2xlYXIoKTtcbiAgICBlbmdpbmUuc2xpZGVMb29wZXIuY2xlYXIoKTtcbiAgICBlbmdpbmUucmVzaXplSGFuZGxlci5kZXN0cm95KCk7XG4gICAgZW5naW5lLnNsaWRlc0hhbmRsZXIuZGVzdHJveSgpO1xuICAgIGVuZ2luZS5zbGlkZXNJblZpZXcuZGVzdHJveSgpO1xuICAgIGVuZ2luZS5hbmltYXRpb24uZGVzdHJveSgpO1xuICAgIHBsdWdpbnNIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICBtZWRpYUhhbmRsZXJzLmNsZWFyKCk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgICBtZWRpYUhhbmRsZXJzLmNsZWFyKCk7XG4gICAgZGVBY3RpdmF0ZSgpO1xuICAgIGV2ZW50SGFuZGxlci5lbWl0KCdkZXN0cm95Jyk7XG4gIH1cbiAgZnVuY3Rpb24gc2Nyb2xsVG8oaW5kZXgsIGp1bXAsIGRpcmVjdGlvbikge1xuICAgIGlmICghb3B0aW9ucy5hY3RpdmUgfHwgZGVzdHJveWVkKSByZXR1cm47XG4gICAgZW5naW5lLnNjcm9sbEJvZHkudXNlQmFzZUZyaWN0aW9uKCkudXNlRHVyYXRpb24oanVtcCA9PT0gdHJ1ZSA/IDAgOiBvcHRpb25zLmR1cmF0aW9uKTtcbiAgICBlbmdpbmUuc2Nyb2xsVG8uaW5kZXgoaW5kZXgsIGRpcmVjdGlvbiB8fCAwKTtcbiAgfVxuICBmdW5jdGlvbiBzY3JvbGxOZXh0KGp1bXApIHtcbiAgICBjb25zdCBuZXh0ID0gZW5naW5lLmluZGV4LmFkZCgxKS5nZXQoKTtcbiAgICBzY3JvbGxUbyhuZXh0LCBqdW1wLCAtMSk7XG4gIH1cbiAgZnVuY3Rpb24gc2Nyb2xsUHJldihqdW1wKSB7XG4gICAgY29uc3QgcHJldiA9IGVuZ2luZS5pbmRleC5hZGQoLTEpLmdldCgpO1xuICAgIHNjcm9sbFRvKHByZXYsIGp1bXAsIDEpO1xuICB9XG4gIGZ1bmN0aW9uIGNhblNjcm9sbE5leHQoKSB7XG4gICAgY29uc3QgbmV4dCA9IGVuZ2luZS5pbmRleC5hZGQoMSkuZ2V0KCk7XG4gICAgcmV0dXJuIG5leHQgIT09IHNlbGVjdGVkU2Nyb2xsU25hcCgpO1xuICB9XG4gIGZ1bmN0aW9uIGNhblNjcm9sbFByZXYoKSB7XG4gICAgY29uc3QgcHJldiA9IGVuZ2luZS5pbmRleC5hZGQoLTEpLmdldCgpO1xuICAgIHJldHVybiBwcmV2ICE9PSBzZWxlY3RlZFNjcm9sbFNuYXAoKTtcbiAgfVxuICBmdW5jdGlvbiBzY3JvbGxTbmFwTGlzdCgpIHtcbiAgICByZXR1cm4gZW5naW5lLnNjcm9sbFNuYXBMaXN0O1xuICB9XG4gIGZ1bmN0aW9uIHNjcm9sbFByb2dyZXNzKCkge1xuICAgIHJldHVybiBlbmdpbmUuc2Nyb2xsUHJvZ3Jlc3MuZ2V0KGVuZ2luZS5sb2NhdGlvbi5nZXQoKSk7XG4gIH1cbiAgZnVuY3Rpb24gc2VsZWN0ZWRTY3JvbGxTbmFwKCkge1xuICAgIHJldHVybiBlbmdpbmUuaW5kZXguZ2V0KCk7XG4gIH1cbiAgZnVuY3Rpb24gcHJldmlvdXNTY3JvbGxTbmFwKCkge1xuICAgIHJldHVybiBlbmdpbmUuaW5kZXhQcmV2aW91cy5nZXQoKTtcbiAgfVxuICBmdW5jdGlvbiBzbGlkZXNJblZpZXcoKSB7XG4gICAgcmV0dXJuIGVuZ2luZS5zbGlkZXNJblZpZXcuZ2V0KCk7XG4gIH1cbiAgZnVuY3Rpb24gc2xpZGVzTm90SW5WaWV3KCkge1xuICAgIHJldHVybiBlbmdpbmUuc2xpZGVzSW5WaWV3LmdldChmYWxzZSk7XG4gIH1cbiAgZnVuY3Rpb24gcGx1Z2lucygpIHtcbiAgICByZXR1cm4gcGx1Z2luQXBpcztcbiAgfVxuICBmdW5jdGlvbiBpbnRlcm5hbEVuZ2luZSgpIHtcbiAgICByZXR1cm4gZW5naW5lO1xuICB9XG4gIGZ1bmN0aW9uIHJvb3ROb2RlKCkge1xuICAgIHJldHVybiByb290O1xuICB9XG4gIGZ1bmN0aW9uIGNvbnRhaW5lck5vZGUoKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuICBmdW5jdGlvbiBzbGlkZU5vZGVzKCkge1xuICAgIHJldHVybiBzbGlkZXM7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBjYW5TY3JvbGxOZXh0LFxuICAgIGNhblNjcm9sbFByZXYsXG4gICAgY29udGFpbmVyTm9kZSxcbiAgICBpbnRlcm5hbEVuZ2luZSxcbiAgICBkZXN0cm95LFxuICAgIG9mZixcbiAgICBvbixcbiAgICBlbWl0LFxuICAgIHBsdWdpbnMsXG4gICAgcHJldmlvdXNTY3JvbGxTbmFwLFxuICAgIHJlSW5pdCxcbiAgICByb290Tm9kZSxcbiAgICBzY3JvbGxOZXh0LFxuICAgIHNjcm9sbFByZXYsXG4gICAgc2Nyb2xsUHJvZ3Jlc3MsXG4gICAgc2Nyb2xsU25hcExpc3QsXG4gICAgc2Nyb2xsVG8sXG4gICAgc2VsZWN0ZWRTY3JvbGxTbmFwLFxuICAgIHNsaWRlTm9kZXMsXG4gICAgc2xpZGVzSW5WaWV3LFxuICAgIHNsaWRlc05vdEluVmlld1xuICB9O1xuICBhY3RpdmF0ZSh1c2VyT3B0aW9ucywgdXNlclBsdWdpbnMpO1xuICBzZXRUaW1lb3V0KCgpID0+IGV2ZW50SGFuZGxlci5lbWl0KCdpbml0JyksIDApO1xuICByZXR1cm4gc2VsZjtcbn1cbkVtYmxhQ2Fyb3VzZWwuZ2xvYmFsT3B0aW9ucyA9IHVuZGVmaW5lZDtcblxuZXhwb3J0IHsgRW1ibGFDYXJvdXNlbCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbWJsYS1jYXJvdXNlbC5lc20uanMubWFwXG4iXSwibmFtZXMiOlsiaXNOdW1iZXIiLCJzdWJqZWN0IiwiaXNTdHJpbmciLCJpc0Jvb2xlYW4iLCJpc09iamVjdCIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsIm1hdGhBYnMiLCJuIiwiTWF0aCIsImFicyIsIm1hdGhTaWduIiwic2lnbiIsImRlbHRhQWJzIiwidmFsdWVCIiwidmFsdWVBIiwiZmFjdG9yQWJzIiwiZGlmZiIsImFycmF5S2V5cyIsImFycmF5Iiwib2JqZWN0S2V5cyIsIm1hcCIsIk51bWJlciIsImFycmF5TGFzdCIsImFycmF5TGFzdEluZGV4IiwibWF4IiwibGVuZ3RoIiwiYXJyYXlJc0xhc3RJbmRleCIsImluZGV4IiwiYXJyYXlGcm9tTnVtYmVyIiwic3RhcnRBdCIsIkFycmF5IiwiZnJvbSIsIl8iLCJpIiwib2JqZWN0Iiwia2V5cyIsIm9iamVjdHNNZXJnZURlZXAiLCJvYmplY3RBIiwib2JqZWN0QiIsInJlZHVjZSIsIm1lcmdlZE9iamVjdHMiLCJjdXJyZW50T2JqZWN0IiwiZm9yRWFjaCIsImtleSIsImFyZU9iamVjdHMiLCJpc01vdXNlRXZlbnQiLCJldnQiLCJvd25lcldpbmRvdyIsIk1vdXNlRXZlbnQiLCJBbGlnbm1lbnQiLCJhbGlnbiIsInZpZXdTaXplIiwicHJlZGVmaW5lZCIsInN0YXJ0IiwiY2VudGVyIiwiZW5kIiwibWVhc3VyZSIsInNlbGYiLCJFdmVudFN0b3JlIiwibGlzdGVuZXJzIiwiYWRkIiwibm9kZSIsInR5cGUiLCJoYW5kbGVyIiwib3B0aW9ucyIsInBhc3NpdmUiLCJyZW1vdmVMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibGVnYWN5TWVkaWFRdWVyeUxpc3QiLCJhZGRMaXN0ZW5lciIsInB1c2giLCJjbGVhciIsImZpbHRlciIsInJlbW92ZSIsIkFuaW1hdGlvbnMiLCJvd25lckRvY3VtZW50IiwidXBkYXRlIiwicmVuZGVyIiwiZG9jdW1lbnRWaXNpYmxlSGFuZGxlciIsInRpbWVTdGVwIiwibGFzdFRpbWVTdGFtcCIsImxhZyIsImFuaW1hdGlvbkZyYW1lIiwiaW5pdCIsImhpZGRlbiIsInJlc2V0IiwiZGVzdHJveSIsInN0b3AiLCJhbmltYXRlIiwidGltZVN0YW1wIiwiZWxhcHNlZCIsImxhZ09mZnNldCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiQXhpcyIsImF4aXMiLCJkaXJlY3Rpb24iLCJzY3JvbGwiLCJjcm9zcyIsInN0YXJ0RWRnZSIsImdldFN0YXJ0RWRnZSIsImVuZEVkZ2UiLCJnZXRFbmRFZGdlIiwibWVhc3VyZVNpemUiLCJub2RlUmVjdCIsIndpZHRoIiwiaGVpZ2h0IiwiTGltaXQiLCJtaW4iLCJyZWFjaGVkTWluIiwicmVhY2hlZE1heCIsInJlYWNoZWRBbnkiLCJjb25zdHJhaW4iLCJyZW1vdmVPZmZzZXQiLCJjZWlsIiwiQ291bnRlciIsImxvb3AiLCJsb29wRW5kIiwiY291bnRlciIsIndpdGhpbkxpbWl0IiwiZ2V0Iiwic2V0IiwiY2xvbmUiLCJEaXJlY3Rpb24iLCJhcHBseSIsIkRyYWdIYW5kbGVyIiwicm9vdE5vZGUiLCJ0YXJnZXQiLCJkcmFnVHJhY2tlciIsImxvY2F0aW9uIiwiYW5pbWF0aW9uIiwic2Nyb2xsVG8iLCJzY3JvbGxCb2R5Iiwic2Nyb2xsVGFyZ2V0IiwiZXZlbnRIYW5kbGVyIiwicGVyY2VudE9mVmlldyIsImRyYWdGcmVlIiwiZHJhZ1RocmVzaG9sZCIsInNraXBTbmFwcyIsImJhc2VGcmljdGlvbiIsIndhdGNoRHJhZyIsImNyb3NzQXhpcyIsImZvY3VzTm9kZXMiLCJub25QYXNzaXZlRXZlbnQiLCJpbml0RXZlbnRzIiwiZHJhZ0V2ZW50cyIsImdvVG9OZXh0VGhyZXNob2xkIiwic25hcEZvcmNlQm9vc3QiLCJtb3VzZSIsInRvdWNoIiwiZnJlZUZvcmNlQm9vc3QiLCJiYXNlU3BlZWQiLCJpc01vdmluZyIsInN0YXJ0U2Nyb2xsIiwic3RhcnRDcm9zcyIsInBvaW50ZXJJc0Rvd24iLCJwcmV2ZW50U2Nyb2xsIiwicHJldmVudENsaWNrIiwiaXNNb3VzZSIsImVtYmxhQXBpIiwiZG93bklmQWxsb3dlZCIsImRvd24iLCJwcmV2ZW50RGVmYXVsdCIsInVuZGVmaW5lZCIsInVwIiwiY2xpY2siLCJhZGREcmFnRXZlbnRzIiwibW92ZSIsImlzRm9jdXNOb2RlIiwibm9kZU5hbWUiLCJpbmNsdWRlcyIsImZvcmNlQm9vc3QiLCJib29zdCIsImFsbG93ZWRGb3JjZSIsImZvcmNlIiwidGFyZ2V0Q2hhbmdlZCIsIm5leHQiLCJiYXNlRm9yY2UiLCJieURpc3RhbmNlIiwiZGlzdGFuY2UiLCJieUluZGV4IiwiaXNNb3VzZUV2dCIsImJ1dHRvbiIsImJ1dHRvbnMiLCJwb2ludGVyRG93biIsInVzZUZyaWN0aW9uIiwidXNlRHVyYXRpb24iLCJyZWFkUG9pbnQiLCJlbWl0IiwibGFzdFNjcm9sbCIsImxhc3RDcm9zcyIsImRpZmZTY3JvbGwiLCJkaWZmQ3Jvc3MiLCJjYW5jZWxhYmxlIiwicG9pbnRlck1vdmUiLCJjdXJyZW50TG9jYXRpb24iLCJyYXdGb3JjZSIsInBvaW50ZXJVcCIsImZvcmNlRmFjdG9yIiwic3BlZWQiLCJmcmljdGlvbiIsInN0b3BQcm9wYWdhdGlvbiIsIkRyYWdUcmFja2VyIiwibG9nSW50ZXJ2YWwiLCJzdGFydEV2ZW50IiwibGFzdEV2ZW50IiwicmVhZFRpbWUiLCJldnRBeGlzIiwicHJvcGVydHkiLCJjb29yZCIsInRvdWNoZXMiLCJleHBpcmVkIiwiZGlmZkRyYWciLCJkaWZmVGltZSIsImlzRmxpY2siLCJOb2RlUmVjdHMiLCJvZmZzZXRUb3AiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXQiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJQZXJjZW50T2ZWaWV3IiwiUmVzaXplSGFuZGxlciIsImNvbnRhaW5lciIsInNsaWRlcyIsIndhdGNoUmVzaXplIiwibm9kZVJlY3RzIiwicmVzaXplT2JzZXJ2ZXIiLCJjb250YWluZXJTaXplIiwic2xpZGVTaXplcyIsImRlc3Ryb3llZCIsInJlYWRTaXplIiwiZGVmYXVsdENhbGxiYWNrIiwiZW50cmllcyIsImVudHJ5IiwiaXNDb250YWluZXIiLCJzbGlkZUluZGV4IiwiaW5kZXhPZiIsImxhc3RTaXplIiwibmV3U2l6ZSIsImRpZmZTaXplIiwicmVJbml0IiwiUmVzaXplT2JzZXJ2ZXIiLCJvYnNlcnZlTm9kZXMiLCJjb25jYXQiLCJvYnNlcnZlIiwiZGlzY29ubmVjdCIsIlNjcm9sbEJvZHkiLCJvZmZzZXRMb2NhdGlvbiIsImJhc2VEdXJhdGlvbiIsImJvZHlWZWxvY2l0eSIsInNjcm9sbERpcmVjdGlvbiIsInNjcm9sbER1cmF0aW9uIiwic2Nyb2xsRnJpY3Rpb24iLCJyYXdMb2NhdGlvbiIsInJhd0xvY2F0aW9uUHJldmlvdXMiLCJzZWVrIiwiaXNJbnN0YW50IiwiZGlyZWN0aW9uRGlmZiIsInNldHRsZWQiLCJkdXJhdGlvbiIsInZlbG9jaXR5IiwidXNlQmFzZUR1cmF0aW9uIiwidXNlQmFzZUZyaWN0aW9uIiwiU2Nyb2xsQm91bmRzIiwibGltaXQiLCJwdWxsQmFja1RocmVzaG9sZCIsImVkZ2VPZmZzZXRUb2xlcmFuY2UiLCJmcmljdGlvbkxpbWl0IiwiZGlzYWJsZWQiLCJzaG91bGRDb25zdHJhaW4iLCJlZGdlIiwiZGlmZlRvRWRnZSIsImRpZmZUb1RhcmdldCIsInN1YnRyYWN0IiwidG9nZ2xlQWN0aXZlIiwiYWN0aXZlIiwiU2Nyb2xsQ29udGFpbiIsImNvbnRlbnRTaXplIiwic25hcHNBbGlnbmVkIiwiY29udGFpblNjcm9sbCIsInBpeGVsVG9sZXJhbmNlIiwic2Nyb2xsQm91bmRzIiwic25hcHNCb3VuZGVkIiwibWVhc3VyZUJvdW5kZWQiLCJzY3JvbGxDb250YWluTGltaXQiLCJmaW5kU2Nyb2xsQ29udGFpbkxpbWl0Iiwic25hcHNDb250YWluZWQiLCJtZWFzdXJlQ29udGFpbmVkIiwic3RhcnRTbmFwIiwiZW5kU25hcCIsImxhc3RJbmRleE9mIiwic25hcEFsaWduZWQiLCJpc0ZpcnN0IiwiaXNMYXN0Iiwic2Nyb2xsQm91bmQiLCJwYXJzZUZsb2F0IiwidG9GaXhlZCIsInNsaWNlIiwiU2Nyb2xsTGltaXQiLCJzY3JvbGxTbmFwcyIsIlNjcm9sbExvb3BlciIsInZlY3RvcnMiLCJqb2ludFNhZmV0eSIsInNob3VsZExvb3AiLCJsb29wRGlzdGFuY2UiLCJ2IiwiU2Nyb2xsUHJvZ3Jlc3MiLCJTY3JvbGxTbmFwcyIsImFsaWdubWVudCIsImNvbnRhaW5lclJlY3QiLCJzbGlkZVJlY3RzIiwic2xpZGVzVG9TY3JvbGwiLCJncm91cFNsaWRlcyIsImFsaWdubWVudHMiLCJtZWFzdXJlU2l6ZXMiLCJzbmFwcyIsIm1lYXN1cmVVbmFsaWduZWQiLCJtZWFzdXJlQWxpZ25lZCIsInJlY3RzIiwicmVjdCIsInNuYXAiLCJnIiwiU2xpZGVSZWdpc3RyeSIsImNvbnRhaW5TbmFwcyIsInNsaWRlSW5kZXhlcyIsInNsaWRlUmVnaXN0cnkiLCJjcmVhdGVTbGlkZVJlZ2lzdHJ5IiwiZ3JvdXBlZFNsaWRlSW5kZXhlcyIsImRvTm90Q29udGFpbiIsImdyb3VwIiwiZ3JvdXBzIiwicmFuZ2UiLCJTY3JvbGxUYXJnZXQiLCJ0YXJnZXRWZWN0b3IiLCJtaW5EaXN0YW5jZSIsImRpc3RhbmNlcyIsInNvcnQiLCJhIiwiYiIsImZpbmRUYXJnZXRTbmFwIiwiYXNjRGlmZnNUb1NuYXBzIiwic2Nyb2xsU25hcCIsImRpZmZUb1NuYXAiLCJzaG9ydGN1dCIsImQxIiwiZDIiLCJ0YXJnZXRzIiwibWF0Y2hpbmdUYXJnZXRzIiwidCIsInRhcmdldFNuYXBEaXN0YW5jZSIsInJlYWNoZWRCb3VuZCIsInNuYXBEaXN0YW5jZSIsIlNjcm9sbFRvIiwiaW5kZXhDdXJyZW50IiwiaW5kZXhQcmV2aW91cyIsImRpc3RhbmNlRGlmZiIsImluZGV4RGlmZiIsInRhcmdldEluZGV4IiwiU2xpZGVGb2N1cyIsInJvb3QiLCJldmVudFN0b3JlIiwibGFzdFRhYlByZXNzVGltZSIsImRvY3VtZW50IiwicmVnaXN0ZXJUYWJQcmVzcyIsImFkZFNsaWRlRm9jdXNFdmVudCIsImV2ZW50IiwiY29kZSIsIkRhdGUiLCJnZXRUaW1lIiwic2xpZGUiLCJmb2N1cyIsIm5vd1RpbWUiLCJzY3JvbGxMZWZ0IiwiZmluZEluZGV4IiwiY2FwdHVyZSIsIlZlY3RvcjFEIiwiaW5pdGlhbFZhbHVlIiwidmFsdWUiLCJub3JtYWxpemVJbnB1dCIsIlRyYW5zbGF0ZSIsInRyYW5zbGF0ZSIsIngiLCJ5IiwiY29udGFpbmVyU3R5bGUiLCJzdHlsZSIsInRvIiwidHJhbnNmb3JtIiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiU2xpZGVMb29wZXIiLCJzbGlkZVNpemVzV2l0aEdhcHMiLCJyb3VuZGluZ1NhZmV0eSIsImFzY0l0ZW1zIiwiZGVzY0l0ZW1zIiwicmV2ZXJzZSIsImxvb3BQb2ludHMiLCJzdGFydFBvaW50cyIsImVuZFBvaW50cyIsInJlbW92ZVNsaWRlU2l6ZXMiLCJpbmRleGVzIiwic2xpZGVzSW5HYXAiLCJnYXAiLCJyZW1haW5pbmdHYXAiLCJmaW5kU2xpZGVCb3VuZHMiLCJmaW5kTG9vcFBvaW50cyIsImlzRW5kRWRnZSIsInNsaWRlQm91bmRzIiwiaW5pdGlhbCIsImFsdGVyZWQiLCJib3VuZEVkZ2UiLCJsb29wUG9pbnQiLCJzbGlkZUxvY2F0aW9uIiwiY2FuTG9vcCIsImV2ZXJ5Iiwib3RoZXJJbmRleGVzIiwic2hpZnRMb2NhdGlvbiIsIlNsaWRlc0hhbmRsZXIiLCJ3YXRjaFNsaWRlcyIsIm11dGF0aW9uT2JzZXJ2ZXIiLCJtdXRhdGlvbnMiLCJtdXRhdGlvbiIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJjaGlsZExpc3QiLCJTbGlkZXNJblZpZXciLCJ0aHJlc2hvbGQiLCJpbnRlcnNlY3Rpb25FbnRyeU1hcCIsImluVmlld0NhY2hlIiwibm90SW5WaWV3Q2FjaGUiLCJpbnRlcnNlY3Rpb25PYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwicGFyZW50RWxlbWVudCIsImNyZWF0ZUluVmlld0xpc3QiLCJpblZpZXciLCJsaXN0IiwicGFyc2VJbnQiLCJpc0ludGVyc2VjdGluZyIsImluVmlld01hdGNoIiwibm90SW5WaWV3TWF0Y2giLCJTbGlkZVNpemVzIiwicmVhZEVkZ2VHYXAiLCJ3aXRoRWRnZUdhcCIsInN0YXJ0R2FwIiwibWVhc3VyZVN0YXJ0R2FwIiwiZW5kR2FwIiwibWVhc3VyZUVuZEdhcCIsIm1lYXN1cmVXaXRoR2FwcyIsInNsaWRlUmVjdCIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiU2xpZGVzVG9TY3JvbGwiLCJncm91cEJ5TnVtYmVyIiwiYnlOdW1iZXIiLCJncm91cFNpemUiLCJieVNpemUiLCJyZWN0QiIsInJlY3RBIiwiZWRnZUEiLCJlZGdlQiIsImdhcEEiLCJnYXBCIiwiY2h1bmtTaXplIiwiY3VycmVudFNpemUiLCJwcmV2aW91c1NpemUiLCJFbmdpbmUiLCJzY3JvbGxBeGlzIiwiY29udGVudERpcmVjdGlvbiIsInN0YXJ0SW5kZXgiLCJpblZpZXdUaHJlc2hvbGQiLCJkcmFnSGFuZGxlciIsInNjcm9sbExvb3BlciIsInNsaWRlTG9vcGVyIiwiaGFzU2V0dGxlZCIsImVuZ2luZSIsInN0YXJ0TG9jYXRpb24iLCJzY3JvbGxQcm9ncmVzcyIsInNsaWRlc0luVmlldyIsInNsaWRlRm9jdXMiLCJyZXNpemVIYW5kbGVyIiwic2Nyb2xsU25hcExpc3QiLCJzbGlkZXNIYW5kbGVyIiwiRXZlbnRIYW5kbGVyIiwiYXBpIiwiZ2V0TGlzdGVuZXJzIiwiZSIsIm9uIiwiY2IiLCJvZmYiLCJkZWZhdWx0T3B0aW9ucyIsImJyZWFrcG9pbnRzIiwiT3B0aW9uc0hhbmRsZXIiLCJtZXJnZU9wdGlvbnMiLCJvcHRpb25zQSIsIm9wdGlvbnNCIiwib3B0aW9uc0F0TWVkaWEiLCJtYXRjaGVkTWVkaWFPcHRpb25zIiwibWVkaWEiLCJtYXRjaE1lZGlhIiwibWF0Y2hlcyIsIm1lZGlhT3B0aW9uIiwib3B0aW9uc01lZGlhUXVlcmllcyIsIm9wdGlvbnNMaXN0IiwiYWNjIiwibWVkaWFRdWVyaWVzIiwiUGx1Z2luc0hhbmRsZXIiLCJvcHRpb25zSGFuZGxlciIsImFjdGl2ZVBsdWdpbnMiLCJwbHVnaW5zIiwicGx1Z2luIiwiYXNzaWduIiwibmFtZSIsIkVtYmxhQ2Fyb3VzZWwiLCJ1c2VyT3B0aW9ucyIsInVzZXJQbHVnaW5zIiwiZGVmYXVsdFZpZXciLCJwbHVnaW5zSGFuZGxlciIsIm1lZGlhSGFuZGxlcnMiLCJyZUFjdGl2YXRlIiwib3B0aW9uc0Jhc2UiLCJnbG9iYWxPcHRpb25zIiwicGx1Z2luTGlzdCIsInBsdWdpbkFwaXMiLCJzdG9yZUVsZW1lbnRzIiwidXNlckNvbnRhaW5lciIsInVzZXJTbGlkZXMiLCJjdXN0b21Db250YWluZXIiLCJxdWVyeVNlbGVjdG9yIiwiY2hpbGRyZW4iLCJjdXN0b21TbGlkZXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY3JlYXRlRW5naW5lIiwib3B0aW9uc1dpdGhvdXRMb29wIiwiYWN0aXZhdGUiLCJ3aXRoT3B0aW9ucyIsIndpdGhQbHVnaW5zIiwicXVlcnkiLCJvZmZzZXRQYXJlbnQiLCJzZWxlY3RlZFNjcm9sbFNuYXAiLCJkZUFjdGl2YXRlIiwianVtcCIsInNjcm9sbE5leHQiLCJzY3JvbGxQcmV2IiwicHJldiIsImNhblNjcm9sbE5leHQiLCJjYW5TY3JvbGxQcmV2IiwicHJldmlvdXNTY3JvbGxTbmFwIiwic2xpZGVzTm90SW5WaWV3IiwiaW50ZXJuYWxFbmdpbmUiLCJjb250YWluZXJOb2RlIiwic2xpZGVOb2RlcyIsInNldFRpbWVvdXQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/embla-carousel/esm/embla-carousel.esm.js\n");

/***/ })

};
;